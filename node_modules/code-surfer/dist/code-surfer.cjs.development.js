'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var mdxDeck = require('mdx-deck');
var diff = require('diff');
var Prism = _interopDefault(require('prismjs'));
var flat = _interopDefault(require('array.prototype.flat'));
require('prismjs/components/prism-markup');
require('prismjs/components/prism-bash');
require('prismjs/components/prism-clike');
require('prismjs/components/prism-c');
require('prismjs/components/prism-cpp');
require('prismjs/components/prism-css');
require('prismjs/components/prism-css-extras');
require('prismjs/components/prism-javascript');
require('prismjs/components/prism-jsx');
require('prismjs/components/prism-js-extras');
require('prismjs/components/prism-coffeescript');
require('prismjs/components/prism-diff');
require('prismjs/components/prism-git');
require('prismjs/components/prism-go');
require('prismjs/components/prism-graphql');
require('prismjs/components/prism-json');
require('prismjs/components/prism-less');
require('prismjs/components/prism-makefile');
require('prismjs/components/prism-markdown');
require('prismjs/components/prism-objectivec');
require('prismjs/components/prism-ocaml');
require('prismjs/components/prism-python');
require('prismjs/components/prism-reason');
require('prismjs/components/prism-sass');
require('prismjs/components/prism-scss');
require('prismjs/components/prism-sql');
require('prismjs/components/prism-stylus');
require('prismjs/components/prism-typescript');
require('prismjs/components/prism-wasm');
require('prismjs/components/prism-yaml');
var shellQuote = require('shell-quote');
var rebound = _interopDefault(require('rebound'));
var router = require('@reach/router');
var core = require('@emotion/core');
var reactSwipeable = require('react-swipeable');

function Code() {
  // We only use this to inspect the props from the element
  return null;
}

function Step() {
  return null;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

function UnknownError(_ref) {
  var error = _ref.error;
  // TODO link to create issue
  return React__default.createElement(ErrorBox, {
    header: "Oops, there's a problem",
    body: error.toString()
  });
}
function grammarNotFound(_ref2) {
  var lang = _ref2.lang;
  return {
    element: React__default.createElement(ErrorBox, {
      header: "Oops, there's a problem",
      body: React__default.createElement(React__default.Fragment, null, "Syntax highlighter for ", React__default.createElement(Mark, null, "\"", lang, "\""), " not found.", React__default.createElement("p", null, "You can try importing it from prismjs with: ", React__default.createElement("br", null), React__default.createElement(Mark, null, "import \"prismjs/components/prism-", lang, "\"")), "(See", " ", React__default.createElement("a", {
        href: "https://prismjs.com/#supported-languages",
        style: {
          color: "grey"
        }
      }, "all the supported languages"), ")")
    })
  };
}
function invalidFocusNumber(n) {
  return {
    withFocusString: function withFocusString(focusString) {
      return {
        withStepIndex: function withStepIndex(stepIndex) {
          return {
            element: React__default.createElement(ErrorBox, {
              header: React__default.createElement(StepErrorHeader, {
                stepIndex: stepIndex
              }),
              body: React__default.createElement(React__default.Fragment, null, React__default.createElement(Mark, null, "\"", n, "\""), " isn't a valid number", " ", n != focusString && React__default.createElement(Mark, null, " (in \"", focusString, "\")"))
            })
          };
        }
      };
    }
  };
}
function invalidLineOrColumnNumber() {
  return {
    withFocusString: function withFocusString(focusString) {
      return {
        withStepIndex: function withStepIndex(stepIndex) {
          return {
            element: React__default.createElement(ErrorBox, {
              header: React__default.createElement(StepErrorHeader, {
                stepIndex: stepIndex
              }),
              body: React__default.createElement(React__default.Fragment, null, "Are you using \"0\" as a line or column number", " ", React__default.createElement(Mark, null, "in \"", focusString, "\""), "?", React__default.createElement("br", null), "(Line and column numbers should start at 1, not 0) ", React__default.createElement("br", null))
            })
          };
        }
      };
    }
  };
}

function ErrorBox(_ref3) {
  var header = _ref3.header,
      body = _ref3.body;
  return React__default.createElement("div", {
    style: {
      background: "#290000",
      color: "#b96f70",
      border: "2px solid #b96f70",
      padding: "10px 30px",
      maxWidth: "90vw",
      margin: "0 auto",
      fontFamily: "monospace",
      fontSize: "1rem"
    }
  }, React__default.createElement("h3", null, header), React__default.createElement("p", null, body));
}

function StepErrorHeader(_ref4) {
  var stepIndex = _ref4.stepIndex;
  return React__default.createElement(React__default.Fragment, null, "Oops, there's a problem with the", " ", React__default.createElement(Mark, null, stepIndex + 1, React__default.createElement("sup", null, ordinal(stepIndex + 1)), " step"));
}

function Mark(_ref5) {
  var children = _ref5.children;
  return React__default.createElement("mark", {
    style: {
      background: "none",
      color: "pink",
      fontWeight: "bolder"
    }
  }, children);
}

function ordinal(i) {
  var j = i % 10,
      k = i % 100;

  if (j == 1 && k != 11) {
    return "st";
  }

  if (j == 2 && k != 12) {
    return "nd";
  }

  if (j == 3 && k != 13) {
    return "rd";
  }

  return "th";
}

var newlineRe = /\r\n|\r|\n/; // Take a list of nested tokens
// (token.content may contain an array of tokens)
// and flatten it so content is always a string
// and type the type of the leaf

function flattenTokens(tokens) {
  var flatList = [];
  tokens.forEach(function (token) {
    var type = token.type,
        content = token.content;

    if (Array.isArray(content)) {
      flatList.push.apply(flatList, flattenTokens(content));
    } else {
      flatList.push({
        type: type,
        content: content
      });
    }
  });
  return flatList;
}

function wrapToken(prismToken, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  if (typeof prismToken === "string") {
    return {
      type: parentType,
      content: prismToken
    };
  }

  if (Array.isArray(prismToken.content)) {
    return {
      type: prismToken.type,
      content: tokenizeStrings(prismToken.content, prismToken.type)
    };
  }

  return wrapToken(prismToken.content, prismToken.type);
} // Wrap strings in tokens


function tokenizeStrings(prismTokens, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  return prismTokens.map(function (prismToken) {
    return wrapToken(prismToken, parentType);
  });
}

function tokenize(code, language) {
  if (language === void 0) {
    language = "javascript";
  }

  var grammar = Prism.languages[language];

  if (!grammar) {
    throw grammarNotFound({
      lang: language
    });
  }

  var prismTokens = Prism.tokenize(code, Prism.languages[language]);
  var nestedTokens = tokenizeStrings(prismTokens);
  var tokens = flattenTokens(nestedTokens);
  var currentLine = [];
  var lines = [currentLine];
  tokens.forEach(function (token) {
    var contentLines = token.content.split(newlineRe);
    var firstContent = contentLines.shift();

    if (firstContent !== undefined && firstContent !== "") {
      currentLine.push({
        type: token.type,
        content: firstContent
      });
    }

    contentLines.forEach(function (content) {
      currentLine = [];
      lines.push(currentLine);

      if (content !== "") {
        currentLine.push({
          type: token.type,
          content: content
        });
      }
    });
  });
  return lines;
}

var newlineRe$1 = /\r\n|\r|\n/;

function myDiff(oldCode, newCode) {
  var changes = diff.diffLines(oldCode || "", newCode);
  var oldIndex = -1;
  return changes.map(function (_ref) {
    var value = _ref.value,
        count = _ref.count,
        removed = _ref.removed,
        added = _ref.added;
    var lines = value.split(newlineRe$1); // check if last line is empty, if it is, remove it

    var lastLine = lines.pop();

    if (lastLine) {
      lines.push(lastLine);
    }

    var result = {
      oldIndex: oldIndex,
      lines: lines,
      count: count,
      removed: removed,
      added: added
    };

    if (!added) {
      oldIndex += count || 0;
    }

    return result;
  });
}

function insert(array, index, elements) {
  return array.splice.apply(array, [index, 0].concat(elements));
}

function slideDiff(lines, codes, slideIndex, language) {
  var prevLines = lines.filter(function (l) {
    return l.slides.includes(slideIndex - 1);
  });
  var prevCode = codes[slideIndex - 1] || "";
  var currCode = codes[slideIndex];
  var changes = myDiff(prevCode, currCode);
  changes.forEach(function (change) {
    if (change.added) {
      var prevLine = prevLines[change.oldIndex];
      var addAtIndex = lines.indexOf(prevLine) + 1;
      var addLines = change.lines.map(function (content) {
        return {
          content: content,
          slides: [slideIndex],
          tokens: []
        };
      });
      insert(lines, addAtIndex, addLines);
    } else if (!change.removed) {
      for (var j = 1; j <= (change.count || 0); j++) {
        prevLines[change.oldIndex + j].slides.push(slideIndex);
      }
    }
  });
  var tokenLines = tokenize(currCode, language);
  var currLines = lines.filter(function (l) {
    return l.slides.includes(slideIndex);
  });
  currLines.forEach(function (line, index) {
    return line.tokens = tokenLines[index];
  });
}

function parseLines(codes, language) {
  var lines = [];

  for (var slideIndex = 0; slideIndex < codes.length; slideIndex++) {
    slideDiff(lines, codes, slideIndex, language);
  }

  return lines;
}
function getSlides(codes, language) {
  // codes are in reverse cronological order
  var lines = parseLines(codes, language); // console.log("lines", lines);

  return codes.map(function (_, slideIndex) {
    return lines.map(function (line, lineIndex) {
      return {
        content: line.content,
        tokens: line.tokens,
        isNew: !line.slides.includes(slideIndex + 1),
        show: line.slides.includes(slideIndex),
        key: lineIndex
      };
    }).filter(function (line) {
      return line.show;
    });
  });
}
function getCodes(rawSteps) {
  var codes = [];
  rawSteps.forEach(function (s, i) {
    if (s.lang === "diff" && i > 0) {
      codes[i] = diff.applyPatch(codes[i - 1], s.code);
    } else {
      codes[i] = s.code;
    }
  });
  return codes;
}

function parseFocus(focus) {
  if (!focus) {
    throw new Error("Focus cannot be empty");
  }

  try {
    var parts = focus.split(/,(?![^\[]*\])/g).map(parsePart);
    return new Map(flat(parts));
  } catch (error) {
    if (error.withFocusString) {
      throw error.withFocusString(focus);
    } else {
      throw error;
    }
  }
}

function parsePart(part) {
  // a part could be
  // - a line number: "2"
  // - a line range: "5:9"
  // - a line number with a column selector: "2[1,3:5,9]"
  var columnsMatch = part.match(/(\d+)\[(.+)\]/);

  if (columnsMatch) {
    var line = columnsMatch[1],
        columns = columnsMatch[2];
    var columnsList = columns.split(",").map(expandString);
    var lineIndex = Number(line) - 1;
    var columnIndexes = flat(columnsList).map(function (c) {
      return c - 1;
    });
    return [[lineIndex, columnIndexes]];
  } else {
    return expandString(part).map(function (lineNumber) {
      return [lineNumber - 1, true];
    });
  }
}

function expandString(part) {
  // Transforms something like
  // - "1:3" to [1,2,3]
  // - "4" to [4]
  var _part$split = part.split(":"),
      start = _part$split[0],
      end = _part$split[1]; // todo check if start is 0, line numbers and column numbers start at 1


  if (!isNaturalNumber(start)) {
    throw invalidFocusNumber(start);
  }

  var startNumber = Number(start);

  if (startNumber < 1) {
    throw invalidLineOrColumnNumber();
  }

  if (!end) {
    return [startNumber];
  } else {
    if (!isNaturalNumber(end)) {
      throw invalidFocusNumber(end);
    }

    var list = [];

    for (var i = startNumber; i <= +end; i++) {
      list.push(i);
    }

    return list;
  }
}

function isNaturalNumber(n) {
  n = n.toString(); // force the value in case it is not

  var n1 = Math.abs(n),
      n2 = parseInt(n, 10);
  return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}

function parseSteps(rawSteps, lang) {
  var codes = getCodes(rawSteps);
  var stepsLines = getSlides(codes.reverse(), lang).reverse();
  var steps = rawSteps.map(function (step, i) {
    var lines = stepsLines[i];

    try {
      return parseStep(step, lines);
    } catch (e) {
      if (e.withStepIndex) {
        throw e.withStepIndex(i);
      } else {
        throw e;
      }
    }
  });
  steps.forEach(function (step) {
    var lines = step.lines,
        focusMap = step.focusMap;
    lines.forEach(function (line, index) {
      line.focus = focusMap.has(index);
      var columnFocus = focusMap.get(index);
      line.focusPerToken = Array.isArray(columnFocus);

      if (Array.isArray(columnFocus)) {
        // this mutates the tokens array in order to change it to the same line in other steps
        splitTokensToColumns(line.tokens);
        line.tokens = setTokenFocus(line.tokens, columnFocus);
      }
    });
  });
  return steps;
}

function parseStep(step, lines) {
  var focus = step.focus,
      rest = _objectWithoutPropertiesLoose(step, ["focus"]);

  var focusMap = focus ? parseFocus(focus) : getDefaultFocus(lines);
  var focusIndexes = Array.from(focusMap.keys());
  var focusStart = Math.min.apply(Math, focusIndexes);
  var focusEnd = Math.max.apply(Math, focusIndexes);
  return _extends({
    lines: lines,
    focusMap: focusMap,
    focusStart: focusStart,
    focusEnd: focusEnd,
    focusCenter: (focusStart + focusEnd + 1) / 2,
    focusCount: focusEnd - focusStart + 1
  }, rest);
}

function getDefaultFocus(lines) {
  var indexes = lines.map(function (line, index) {
    return line.isNew ? index : -1;
  }).filter(function (index) {
    return index !== -1;
  });
  return new Map(indexes.map(function (i) {
    return [i, true];
  }));
}

function splitTokensToColumns(tokenArray) {
  var tokens = Array.from(tokenArray);
  var key = 0;
  tokenArray.splice(0, tokenArray.length);
  tokens.forEach(function (token) {
    var chars = Array.from(token.content);
    chars.forEach(function (_char) {
      return tokenArray.push(_extends({}, token, {
        content: _char,
        key: key++
      }));
    });
  });
}

function setTokenFocus(tokens, focusColumns) {
  // Assumes that tokens are already splitted in columns
  // Return new token objects to avoid changing other steps tokens
  return tokens.map(function (token, i) {
    return _extends({}, token, {
      focus: focusColumns.includes(i)
    });
  });
}

function makeTheme(prismTheme, override) {
  if (override === void 0) {
    override = {};
  }

  return _extends({
    styles: prismTheme.styles,
    title: {
      background: prismTheme.plain.backgroundColor
    },
    subtitle: {
      color: "#d6deeb",
      background: "rgba(10,10,10,0.9)"
    },
    pre: {
      color: prismTheme.plain.color,
      background: prismTheme.plain.backgroundColor
    },
    code: {
      color: prismTheme.plain.color,
      background: prismTheme.plain.backgroundColor
    }
  }, override);
}

var prismTheme = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata"],
    style: {
      color: "#999988",
      fontStyle: "italic"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["string", "attr-value"],
    style: {
      color: "#e3116c"
    }
  }, {
    types: ["punctuation", "operator"],
    style: {
      color: "#393A34"
    }
  }, {
    types: ["entity", "url", "symbol", "number", "boolean", "variable", "constant", "property", "regex", "inserted"],
    style: {
      color: "#36acaa"
    }
  }, {
    types: ["atrule", "keyword", "attr-name", "selector"],
    style: {
      color: "#00a4db"
    }
  }, {
    types: ["function", "deleted", "tag"],
    style: {
      color: "#d73a49"
    }
  }, {
    types: ["function-variable"],
    style: {
      color: "#6f42c1"
    }
  }, {
    types: ["tag", "selector"],
    style: {
      color: "#00009f"
    }
  }]
};
var theme =
/*#__PURE__*/
makeTheme(prismTheme);

var prismTheme$1 = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [{
    types: ["prolog", "constant", "builtin"],
    style: {
      color: "rgb(189, 147, 249)"
    }
  }, {
    types: ["inserted", "function"],
    style: {
      color: "rgb(80, 250, 123)"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgb(255, 85, 85)"
    }
  }, {
    types: ["changed"],
    style: {
      color: "rgb(255, 184, 108)"
    }
  }, {
    types: ["punctuation", "symbol"],
    style: {
      color: "rgb(248, 248, 242)"
    }
  }, {
    types: ["string", "char", "tag", "selector"],
    style: {
      color: "rgb(255, 121, 198)"
    }
  }, {
    types: ["keyword", "variable"],
    style: {
      color: "rgb(189, 147, 249)",
      fontStyle: "italic"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(98, 114, 164)"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "rgb(241, 250, 140)"
    }
  }]
};
var theme$1 =
/*#__PURE__*/
makeTheme(prismTheme$1);

var prismTheme$2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#6c6783"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#e09142"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#9a86fd"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#eeebff"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#c4b9fe"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "at-rule", "placeholder", "variable"],
    style: {
      color: "#ffcc99"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#c4b9fe"
    }
  }]
};
var theme$2 =
/*#__PURE__*/
makeTheme(prismTheme$2);

var prismTheme$3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#b6ad9a"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#063289"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#b29762"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#2d2006"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#896724"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "at-rule"],
    style: {
      color: "#728fcb"
    }
  }, {
    types: ["placeholder", "variable"],
    style: {
      color: "#93abdc"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#896724"
    }
  }]
};
var theme$3 =
/*#__PURE__*/
makeTheme(prismTheme$3);

var prismTheme$4 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [{
    types: ["changed"],
    style: {
      color: "rgb(162, 191, 252)",
      fontStyle: "italic"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgba(239, 83, 80, 0.56)",
      fontStyle: "italic"
    }
  }, {
    types: ["inserted", "attr-name"],
    style: {
      color: "rgb(173, 219, 103)",
      fontStyle: "italic"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(99, 119, 119)",
      fontStyle: "italic"
    }
  }, {
    types: ["string", "url"],
    style: {
      color: "rgb(173, 219, 103)"
    }
  }, {
    types: ["variable"],
    style: {
      color: "rgb(214, 222, 235)"
    }
  }, {
    types: ["number"],
    style: {
      color: "rgb(247, 140, 108)"
    }
  }, {
    types: ["builtin", "char", "constant", "function"],
    style: {
      color: "rgb(130, 170, 255)"
    }
  }, {
    // This was manually added after the auto-generation
    // so that punctuations are not italicised
    types: ["punctuation"],
    style: {
      color: "rgb(199, 146, 234)"
    }
  }, {
    types: ["selector", "doctype"],
    style: {
      color: "rgb(199, 146, 234)",
      fontStyle: "italic"
    }
  }, {
    types: ["class-name"],
    style: {
      color: "rgb(255, 203, 139)"
    }
  }, {
    types: ["tag", "operator", "keyword"],
    style: {
      color: "rgb(127, 219, 202)"
    }
  }, {
    types: ["boolean"],
    style: {
      color: "rgb(255, 88, 116)"
    }
  }, {
    types: ["property"],
    style: {
      color: "rgb(128, 203, 196)"
    }
  }, {
    types: ["namespace"],
    style: {
      color: "rgb(178, 204, 214)"
    }
  }]
};
var theme$4 =
/*#__PURE__*/
makeTheme(prismTheme$4, {
  title: {
    background: "rgba(1, 22, 39, 0.8)"
  }
});

var colors = {
  "char": "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  "boolean": "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  "function": "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var prismTheme$5 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [{
    types: ["attr-name"],
    style: {
      color: colors.keyword
    }
  }, {
    types: ["attr-value"],
    style: {
      color: colors.string
    }
  }, {
    types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
    style: {
      color: colors.comment
    }
  }, {
    types: ["property", "number", "function-name", "constant", "symbol", "deleted"],
    style: {
      color: colors.primitive
    }
  }, {
    types: ["boolean"],
    style: {
      color: colors["boolean"]
    }
  }, {
    types: ["tag"],
    style: {
      color: colors.tag
    }
  }, {
    types: ["string"],
    style: {
      color: colors.string
    }
  }, {
    types: ["punctuation"],
    style: {
      color: colors.string
    }
  }, {
    types: ["selector", "char", "builtin", "inserted"],
    style: {
      color: colors["char"]
    }
  }, {
    types: ["function"],
    style: {
      color: colors["function"]
    }
  }, {
    types: ["operator", "entity", "url", "variable"],
    style: {
      color: colors.variable
    }
  }, {
    types: ["keyword"],
    style: {
      color: colors.keyword
    }
  }, {
    types: ["at-rule", "class-name"],
    style: {
      color: colors.className
    }
  }, {
    types: ["important"],
    style: {
      fontWeight: 400
    }
  }, {
    types: ["bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }]
};
var theme$5 =
/*#__PURE__*/
makeTheme(prismTheme$5);

var prismTheme$6 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [{
    types: ["changed"],
    style: {
      color: "rgb(255, 238, 128)"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgba(239, 83, 80, 0.56)"
    }
  }, {
    types: ["inserted"],
    style: {
      color: "rgb(173, 219, 103)"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(179, 98, 255)",
      fontStyle: "italic"
    }
  }, {
    types: ["punctuation"],
    style: {
      color: "rgb(255, 255, 255)"
    }
  }, {
    types: ["constant"],
    style: {
      color: "rgb(255, 98, 140)"
    }
  }, {
    types: ["string", "url"],
    style: {
      color: "rgb(165, 255, 144)"
    }
  }, {
    types: ["variable"],
    style: {
      color: "rgb(255, 238, 128)"
    }
  }, {
    types: ["number", "boolean"],
    style: {
      color: "rgb(255, 98, 140)"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "rgb(255, 180, 84)"
    }
  }, {
    types: ["keyword", "operator", "property", "namespace", "tag", "selector", "doctype"],
    style: {
      color: "rgb(255, 157, 0)"
    }
  }, {
    types: ["builtin", "char", "constant", "function", "class-name"],
    style: {
      color: "rgb(250, 208, 0)"
    }
  }]
};
var theme$6 =
/*#__PURE__*/
makeTheme(prismTheme$6);

var prismTheme$7 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [{
    types: ["comment"],
    style: {
      color: "rgb(197, 200, 198)"
    }
  }, {
    types: ["string", "number", "builtin", "variable"],
    style: {
      color: "rgb(150, 152, 150)"
    }
  }, {
    types: ["class-name", "function", "tag", "attr-name"],
    style: {
      color: "rgb(40, 42, 46)"
    }
  }]
};
var theme$7 =
/*#__PURE__*/
makeTheme(prismTheme$7);

var prismTheme$8 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [{
    types: ["prolog"],
    style: {
      color: "rgb(0, 0, 128)"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(106, 153, 85)"
    }
  }, {
    types: ["builtin", "changed", "keyword"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["number", "inserted"],
    style: {
      color: "rgb(181, 206, 168)"
    }
  }, {
    types: ["constant"],
    style: {
      color: "rgb(100, 102, 149)"
    }
  }, {
    types: ["attr-name", "variable"],
    style: {
      color: "rgb(156, 220, 254)"
    }
  }, {
    types: ["deleted", "string", "attr-value"],
    style: {
      color: "rgb(206, 145, 120)"
    }
  }, {
    types: ["selector"],
    style: {
      color: "rgb(215, 186, 125)"
    }
  }, {
    // Fix tag color
    types: ["tag"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    // Fix tag color for HTML
    types: ["tag"],
    languages: ["markup"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["punctuation", "operator"],
    style: {
      color: "rgb(212, 212, 212)"
    }
  }, {
    // Fix punctuation color for HTML
    types: ["punctuation"],
    languages: ["markup"],
    style: {
      color: "#808080"
    }
  }, {
    types: ["function"],
    style: {
      color: "rgb(220, 220, 170)"
    }
  }, {
    types: ["class-name"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    types: ["char"],
    style: {
      color: "rgb(209, 105, 105)"
    }
  }]
};
var theme$8 =
/*#__PURE__*/
makeTheme(prismTheme$8);

var ThemeContext =
/*#__PURE__*/
React__default.createContext(null);

function useSafeTheme() {
  var contextTheme = React__default.useContext(ThemeContext);
  var theme$1 = contextTheme || theme;
  return theme$1;
}

function useTokenStyles() {
  var theme = useSafeTheme();
  var themeStylesByType = React__default.useMemo(function () {
    var themeStylesByType = Object.create(null);
    var styles = theme.styles;
    styles.forEach(function (_ref) {
      var types = _ref.types,
          style = _ref.style;
      types.forEach(function (type) {
        themeStylesByType[type] = Object.assign(themeStylesByType[type] || {}, style);
      });
    });
    return themeStylesByType;
  }, [theme]);
  var getStyleForToken = React__default.useMemo(function () {
    return function (token) {
      return themeStylesByType[token.type] || {};
    };
  }, [themeStylesByType]);
  return getStyleForToken;
}

function usePreStyle() {
  var theme = useSafeTheme();
  return theme.pre || {};
}

function useContainerStyle() {
  var theme = useSafeTheme();
  return theme.container || {};
}

function useTitleStyle() {
  var theme = useSafeTheme();
  var base = {
    position: "absolute",
    top: 0,
    width: "100%",
    margin: 0,
    padding: "1em 0"
  };
  var style = theme.title || {};
  return _extends({}, base, style);
}

function useSubtitleStyle() {
  var theme = useSafeTheme();
  var base = {
    position: "absolute",
    bottom: 0,
    width: "calc(100% - 2em)",
    boxSizing: "border-box",
    margin: "0.3em 1em",
    padding: "0.5em",
    background: "rgba(2,2,2,0.9)"
  };
  var style = theme.subtitle || {};
  return _extends({}, base, style);
}

var Tuple =
/*#__PURE__*/
function () {
  function Tuple(prev, next) {
    this.prev = prev;
    this.next = next;
  }

  var _proto = Tuple.prototype;

  _proto.spread = function spread() {
    var prev = this.prev;
    var next = this.next;
    return [prev, next];
  };

  _proto.select = function select(selector) {
    var _this$spread = this.spread(),
        prev = _this$spread[0],
        next = _this$spread[1];

    var newPrev = prev === null ? null : prev === undefined ? undefined : selector(prev),
        newNext = next === null ? null : next === undefined ? undefined : selector(next);
    return new Tuple(newPrev, newNext);
  };

  _proto.selectMany = function selectMany(selector) {
    var _this$spread2 = this.spread(),
        prev = _this$spread2[0],
        next = _this$spread2[1];

    var newPrev = prev === null ? null : prev === undefined ? undefined : selector(prev),
        newNext = next === null ? null : next === undefined ? undefined : selector(next);
    return new ArrayTuple(newPrev, newNext);
  };

  _proto.get = function get(_key) {
    throw Error("Get only supported in ArrayTuple");
  };

  _proto.map = function map(_mapper) {
    throw Error("Map only supported in ArrayTuple");
  };

  return Tuple;
}();
var ArrayTuple =
/*#__PURE__*/
function (_Tuple) {
  _inheritsLoose(ArrayTuple, _Tuple);

  function ArrayTuple() {
    return _Tuple.apply(this, arguments) || this;
  }

  var _proto2 = ArrayTuple.prototype;

  _proto2._getChildrenMap = function _getChildrenMap() {
    if (!this._dict) {
      var _this$spread3 = this.spread(),
          maybePrevs = _this$spread3[0],
          maybeNexts = _this$spread3[1];

      var prevs = maybePrevs || [];
      var nexts = maybeNexts || [];
      var unsortedMap = new Map(prevs.map(function (prev) {
        return [prev.key, {
          prev: prev
        }];
      }));
      nexts.forEach(function (next) {
        var _ref = unsortedMap.get(next.key) || {
          prev: undefined
        },
            prev = _ref.prev;

        unsortedMap.set(next.key, {
          prev: prev,
          next: next
        });
      });
      var sortedKeys = Array.from(unsortedMap.keys());
      sortedKeys.sort(function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      });
      this._dict = new Map(sortedKeys.map(function (key) {
        var _ref2 = unsortedMap.get(key) || {},
            _ref2$prev = _ref2.prev,
            prev = _ref2$prev === void 0 ? undefined : _ref2$prev,
            _ref2$next = _ref2.next,
            next = _ref2$next === void 0 ? undefined : _ref2$next;

        return [key, new Tuple(prev, next)];
      }));
    }

    return this._dict;
  };

  _proto2.get = function get(key) {
    var childrenMap = this._getChildrenMap();

    return childrenMap.get(key);
  };

  _proto2.map = function map(mapper) {
    var _this = this;

    var childrenMap = this._getChildrenMap();

    var result = [];
    childrenMap.forEach(function (tuple, key) {
      return result.push(mapper(tuple, key, _this));
    });
    return result;
  };

  return ArrayTuple;
}(Tuple);

var Context =
/*#__PURE__*/
function () {
  function Context(tuple, t, parent) {
    this.tuple = tuple;
    this.t = t;
    this.parent = parent;
  }

  var _proto = Context.prototype;

  _proto.useSelect = function useSelect(selector) {
    var _this = this;

    var newTuple = React__default.useMemo(function () {
      return _this.tuple.select(selector);
    }, [this.tuple]);
    return new Context(newTuple, this.t);
  };

  _proto.useSelectMany = function useSelectMany(selector) {
    var _this2 = this;

    var newTuple = React__default.useMemo(function () {
      return _this2.tuple.selectMany(selector);
    }, [this.tuple]);
    return new ListContext(newTuple, this.t);
  };

  _proto.spread = function spread() {
    return this.tuple.spread();
  };

  _proto.animate = function animate(animation, config) {
    if (config === void 0) {
      config = {};
    }

    var _this$tuple$spread = this.tuple.spread(),
        prev = _this$tuple$spread[0],
        next = _this$tuple$spread[1];

    if (config.when && !config.when(prev, next)) {
      return {};
    }

    var staggeredT = this.t;

    if (config.stagger) {
      if (!this.parent) {
        throw Error("Can't use stagger without a parent context");
      }

      var items = this.parent.map(function (childCtx) {
        var _childCtx$spread = childCtx.spread(),
            prevChild = _childCtx$spread[0],
            nextChild = _childCtx$spread[1];

        return {
          isSelected: !config.when || config.when(prevChild, nextChild),
          isThisChild: prevChild === prev && nextChild === next
        };
      }).filter(function (x) {
        return x.isSelected;
      });
      var N = items.length;

      if (N > 1) {
        var currentIndex = items.findIndex(function (x) {
          return x.isThisChild;
        });
        var duration = 1 - config.stagger;
        var tick = config.stagger / (N - 1);
        staggeredT = Math.min(1, Math.max(0, (this.t - currentIndex * tick) / duration));
      }
    }

    return animation(prev, next, staggeredT);
  };

  _proto.animations = function animations(_animations) {
    var _this3 = this;

    var results = _animations.map(function (_ref) {
      var animation = _ref.animation,
          config = _objectWithoutPropertiesLoose(_ref, ["animation"]);

      return _this3.animate(animation, config);
    });

    return merge(results);
  };

  return Context;
}();
var ListContext =
/*#__PURE__*/
function (_Context) {
  _inheritsLoose(ListContext, _Context);

  function ListContext(tuple, t) {
    var _this4;

    _this4 = _Context.call(this, tuple, t) || this;
    _this4.tuple = tuple;
    return _this4;
  }

  var _proto2 = ListContext.prototype;

  _proto2.map = function map(mapper) {
    var _this5 = this;

    return this.tuple.map(function (childTuple, key) {
      return mapper(new Context(childTuple, _this5.t, _this5), key);
    });
  };

  return ListContext;
}(Context);
function useAnimationContext(items, playhead) {
  var prev = items[Math.floor(playhead)];
  var next = items[Math.floor(playhead) + 1];
  var tuple = React__default.useMemo(function () {
    return new Tuple(prev, next);
  }, [prev, next]);
  return new Context(tuple, playhead % 1);
}
var MULTIPLY = "multiply";

function merge(results, composite) {
  if (composite === void 0) {
    composite = MULTIPLY;
  }

  var firstResult = results[0];

  if (results.length < 2) {
    return firstResult;
  }

  if (Array.isArray(firstResult)) {
    return mergeArrays(results, composite);
  } else {
    return mergeObjects(results, composite);
  }
}

function mergeObjects(results, composite) {
  var merged = Object.assign.apply(Object, [{}].concat(results));

  if (composite === MULTIPLY) {
    var opacities = results.map(function (x) {
      return x.opacity;
    }).filter(function (x) {
      return x != null;
    });

    if (opacities.length !== 0) {
      merged.opacity = opacities.reduce(function (a, b) {
        return a * b;
      });
    }
  }

  return merged;
}

function mergeArrays(results, composite) {
  var firstResult = results[0];
  return firstResult.map(function (_, i) {
    return merge(results.map(function (result) {
      return result[i];
    }), composite);
  });
}

var easing = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

var MULTIPLY$1 = "multiply";
/* eslint-disable */

function mergeResults(results, composite) {
  if (composite === void 0) {
    composite = null;
  }

  var firstResult = results[0];

  if (results.length < 2) {
    return firstResult;
  }

  if (Array.isArray(firstResult)) {
    return firstResult.map(function (_, i) {
      return mergeResults(results.map(function (result) {
        return result[i];
      }), composite);
    });
  } else {
    var merged = Object.assign.apply(Object, [{}].concat(results));

    if (composite === MULTIPLY$1) {
      var opacities = results.map(function (x) {
        return x.opacity;
      }).filter(function (x) {
        return x != null;
      });

      if (opacities.length !== 0) {
        merged.opacity = opacities.reduce(function (a, b) {
          return a * b;
        });
      }
    }

    return merged;
  }
}

var playhead = {
  always: function always(props, context) {
    return function (t) {
      return props.value;
    };
  },
  step: function step(props, context) {
    return function (t) {
      var from = props.from,
          to = props.to;
      return t < 0.5 ? from : to;
    };
  },
  tween: function tween(props, context) {
    return function (t) {
      var from = props.from,
          to = props.to,
          _props$ease = props.ease,
          ease = _props$ease === void 0 ? easing.linear : _props$ease;
      var style = {};
      Object.keys(from).forEach(function (key) {
        var value = from[key] + (to[key] - from[key]) * ease(t);

        if (key === "x") {
          style["transform"] = "translateX(" + value + "px)";
        } else {
          style[key] = value;
        }
      });
      return style;
    };
  },
  chain: function chain(_ref, ctx) {
    var fns = _ref.children,
        durations = _ref.durations;
    return function (t) {
      var style = run(fns[0], 0, ctx);
      var lowerDuration = 0;

      for (var i = 0; i < fns.length; i++) {
        var fn = fns[i];
        var thisDuration = durations[i];
        var upperDuration = lowerDuration + thisDuration;

        if (lowerDuration <= t && t <= upperDuration) {
          var innerT = (t - lowerDuration) / thisDuration;
          style = mergeResults([style, run(fn, innerT, ctx)]);
        } else if (upperDuration < t) {
          // merge the end of previous animation
          style = mergeResults([style, run(fn, 1, ctx)]);
        } else if (t < lowerDuration) {
          // merge the start of future animation
          style = mergeResults([run(fn, 0, ctx), style]);
        }

        lowerDuration = upperDuration;
      }

      return style;
    };
  },
  delay: function delay() {
    return function () {
      return {};
    };
  },
  parallel: function parallel(_ref2, ctx) {
    var fns = _ref2.children;
    return function (t) {
      var styles = fns.map(function (fn) {
        return run(fn, t, ctx);
      });
      var result = mergeResults(styles, MULTIPLY$1);
      return result;
    };
  },
  list: function list(_ref3, ctx) {
    var items = _ref3.forEach,
        children = _ref3.children;
    return function (t) {
      var mapper = children[0];
      var results = items.map(mapper);
      return results.map(function (element) {
        return run(element, t, ctx);
      });
    };
  }
};
function createAnimation(type, config) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var props = _extends({}, config, {
    children: children
  });

  return {
    type: typeof type === "string" ? playhead[type] : type,
    props: props
  };
}
function Context$1() {
  throw Error("shouldnt run Context");
}
function run(node, t, context) {
  if (context === void 0) {
    context = {};
  }

  if (node.type === Context$1) {
    var _node$props = node.props,
        children = _node$props.children,
        patch = _objectWithoutPropertiesLoose(_node$props, ["children"]);

    var newContext = _extends({}, context, patch);

    return run(children[0], t, newContext);
  }

  var result = node.type(node.props, context);

  if (result.type) {
    return run(result, t, context);
  } else {
    return result(t);
  }
}

/* @jsx createAnimation */

function FadeIn() {
  return createAnimation("tween", {
    from: {
      opacity: 0
    },
    to: {
      opacity: 1
    }
  });
}

function FadeOut() {
  return createAnimation("tween", {
    from: {
      opacity: 1
    },
    to: {
      opacity: 0
    }
  });
}

function FadeOutIn() {
  return createAnimation("chain", {
    durations: [0.5, 0.5]
  }, createAnimation(FadeOut, null), createAnimation(FadeIn, null));
}

var dx = 250;
var offOpacity = 0.3;
var outOpacity = 0;
var outHieght = 0;

var SlideToLeft = function SlideToLeft() {
  return createAnimation("tween", {
    from: {
      x: 0,
      opacity: 1
    },
    to: {
      x: -dx,
      opacity: outOpacity
    },
    ease: easing.easeInQuad
  });
};

function ShrinkHeight(_ref) {
  var lineHeight = _ref.lineHeight;

  if (!lineHeight) {
    return createAnimation("step", {
      from: {
        height: null
      },
      to: {
        height: 0
      }
    });
  }

  return createAnimation("tween", {
    from: {
      height: lineHeight
    },
    to: {
      height: outHieght
    },
    ease: easing.easeInOutQuad
  });
}

function ExitLine(_ref2) {
  var lineHeight = _ref2.lineHeight;
  return createAnimation("chain", {
    durations: [0.35, 0.3, 0.35]
  }, createAnimation(SlideToLeft, null), createAnimation(ShrinkHeight, {
    lineHeight: lineHeight
  }));
}

var SlideFromRight = function SlideFromRight() {
  return createAnimation("tween", {
    from: {
      x: dx,
      opacity: outOpacity
    },
    to: {
      x: 0,
      opacity: 1
    },
    ease: easing.easeOutQuad
  });
};

function GrowHeight(_ref3) {
  var lineHeight = _ref3.lineHeight;

  if (!lineHeight) {
    return createAnimation("step", {
      from: {
        height: 0
      },
      to: {
        height: null
      }
    });
  }

  return createAnimation("tween", {
    from: {
      height: outHieght
    },
    to: {
      height: lineHeight
    },
    ease: easing.easeInOutQuad
  });
}

function EnterLine(_ref4) {
  var lineHeight = _ref4.lineHeight;
  return createAnimation("chain", {
    durations: [0.35, 0.3, 0.35]
  }, createAnimation("delay", null), createAnimation(GrowHeight, {
    lineHeight: lineHeight
  }), createAnimation(SlideFromRight, null));
}

var fadeIn = function fadeIn(t) {
  return run(createAnimation(FadeIn, null), t);
};
var fadeOut = function fadeOut(t) {
  return run(createAnimation(FadeOut, null), t);
};
var fadeOutIn = function fadeOutIn(t) {
  return run(createAnimation(FadeOutIn, null), t);
};
function switchText(prev, next, t) {
  // TODO merge with fadeBackground and fadeText
  if (t < 0.5) {
    return prev && prev.value;
  } else {
    return next && next.value;
  }
}

function any(prev, next) {
  return prev || next;
}

var exitLine = function exitLine(prev, next, t) {
  var dimensions = any(prev, next).dimensions;
  return run(createAnimation(ExitLine, {
    lineHeight: dimensions && dimensions.lineHeight
  }), t);
};
var enterLine = function enterLine(prev, next, t) {
  var dimensions = any(prev, next).dimensions;
  return run(createAnimation(EnterLine, {
    lineHeight: dimensions && dimensions.lineHeight
  }), t);
};
var focusLine = function focusLine(prev, next, t) {
  return run(createAnimation("tween", {
    from: {
      opacity: prev && prev.focus ? 1 : offOpacity
    },
    to: {
      opacity: next && next.focus ? 1 : offOpacity
    }
  }), t);
};
var focusToken = function focusToken(prev, next, t) {
  var from = prev && prev.focus === false ? offOpacity : 1;
  var to = next && next.focus === false ? offOpacity : 1;
  return run(createAnimation("tween", {
    from: {
      opacity: from
    },
    to: {
      opacity: to
    }
  }), t);
};
var tween = function tween(from, to) {
  return function (_prev, _next, t) {
    var result = run(createAnimation("tween", {
      from: {
        value: from || 0
      },
      to: {
        value: to || 0
      },
      ease: easing.easeInOutQuad
    }), t);
    return result.value;
  };
};
var scaleToFocus = function scaleToFocus(prev, next, t) {
  var dimensions = any(prev, next).dimensions;

  if (!dimensions) {
    return function (_) {
      return {
        scale: 1
      };
    };
  }

  var prevZoom = getZoom(prev);
  var nextZoom = getZoom(next);
  return run(createAnimation("tween", {
    from: {
      scale: prevZoom || nextZoom
    },
    to: {
      scale: nextZoom || prevZoom
    },
    ease: easing.easeInOutQuad
  }), t);
};

function getZoom(step) {
  if (!step) return null;
  var _step$dimensions = step.dimensions,
      paddingBottom = _step$dimensions.paddingBottom,
      paddingTop = _step$dimensions.paddingTop,
      containerHeight = _step$dimensions.containerHeight,
      containerWidth = _step$dimensions.containerWidth,
      contentWidth = _step$dimensions.contentWidth,
      lineHeight = _step$dimensions.lineHeight;
  var contentHeight = step.focusCount * lineHeight;
  var availableHeight = containerHeight - Math.max(paddingBottom, paddingTop) * 2;
  var yZoom = availableHeight / contentHeight; // if there are lines that are too long for the container

  var xZoom = 0.9 * containerWidth / contentWidth;
  return Math.min(yZoom, 1, xZoom); // return 1;
}

function CodeSurferContainer(_ref) {
  var stepPlayhead = _ref.stepPlayhead,
      dimensions = _ref.dimensions,
      steps = _ref.steps;
  var ctx = useAnimationContext(steps, stepPlayhead);
  return React__default.createElement("div", {
    className: "cs-container",
    style: _extends({}, useContainerStyle(), {
      width: "100%",
      height: dimensions ? dimensions.containerHeight : "100%",
      maxHeight: "100%",
      position: "relative"
    })
  }, React__default.createElement(CodeSurferContent, {
    dimensions: dimensions,
    ctx: ctx
  }), React__default.createElement(Title, {
    ctx: ctx.useSelect(function (step) {
      return step.title;
    })
  }), React__default.createElement(Subtitle, {
    ctx: ctx.useSelect(function (step) {
      return step.subtitle;
    })
  }));
}

var heightChangingAnimations = [{
  animation: exitLine,
  when: function when(prev, next) {
    return prev && !next;
  },
  stagger: 0.2
}, {
  animation: enterLine,
  when: function when(prev, next) {
    return next && !prev;
  },
  stagger: 0.2
}];
/**
 * This part wasn't easy...
 * We need to adjust the scroll as the lines keep changing height
 * So we animate between the prev focus center and the next focus center
 * but taking into acount the height of the lines that are on top of the center
 * for each frame
 */

function useScrollTop(dimensions, stepCtx) {
  if (!dimensions) return 0;
  var linesCtx = stepCtx.useSelectMany(function (step) {
    return step.lines;
  });

  var _stepCtx$spread = stepCtx.spread(),
      prevStep = _stepCtx$spread[0],
      nextStep = _stepCtx$spread[1];

  var _React$useMemo = React__default.useMemo(function () {
    var allPrevLines = linesCtx.map(function (ctx) {
      return ctx.animate(function (prev, _next) {
        return prev;
      });
    });
    var allNextLines = linesCtx.map(function (ctx) {
      return ctx.animate(function (_prev, next) {
        return next;
      });
    });
    var prevCenter = prevStep ? prevStep.focusCenter : 0;
    var nextCenter = nextStep ? nextStep.focusCenter : 0;
    var prevCenterLine = prevStep && prevStep.lines[Math.floor(prevCenter)];
    var nextCenterLine = nextStep && nextStep.lines[Math.floor(nextCenter)];
    var realPrevCenter = prevStep ? allPrevLines.indexOf(prevCenterLine) + prevCenter % 1 : 0;
    var realNextCenter = nextStep ? allNextLines.indexOf(nextCenterLine) + nextCenter % 1 : 0;
    return [realPrevCenter, realNextCenter];
  }, [prevStep, nextStep]),
      realPrevCenter = _React$useMemo[0],
      realNextCenter = _React$useMemo[1];

  var currentCenter = stepCtx.animate(tween(realPrevCenter, realNextCenter));
  var scrollTop = 0;
  var lineStyles = linesCtx.map(function (ctx) {
    return ctx.animations(heightChangingAnimations);
  });
  var i = 0;

  while (i <= currentCenter - 1) {
    var h = lineStyles[i].height;
    scrollTop += h == null ? dimensions.lineHeight : h;
    i += 1;
  }

  if (i != currentCenter) {
    var _h = lineStyles[i].height;
    var height = _h == null ? dimensions.lineHeight : _h;
    scrollTop += height * (currentCenter - i);
  }

  return scrollTop;
}

function CodeSurferContent(_ref2) {
  var dimensions = _ref2.dimensions,
      ctx = _ref2.ctx;
  var ref = React__default.useRef(null);
  var scrollTop = useScrollTop(dimensions, ctx);
  React__default.useLayoutEffect(function () {
    if (ref.current == null) return;
    ref.current.scrollTop = scrollTop;
  }, [scrollTop]);

  var _ctx$animate = ctx.animate(scaleToFocus),
      scale = _ctx$animate.scale;

  var verticalOrigin = dimensions ? dimensions.containerHeight / 2 + scrollTop : 0;
  var linesCtx = ctx.useSelectMany(function (step) {
    return step.lines;
  });
  return React__default.createElement("pre", {
    className: "cs-content",
    ref: ref,
    style: _extends({}, usePreStyle(), {
      margin: 0,
      height: "100%",
      overflow: "hidden"
    })
  }, React__default.createElement("code", {
    className: "cs-scaled-content",
    style: _extends({}, usePreStyle(), {
      display: "block",
      height: dimensions ? dimensions.contentHeight : "100%",
      width: dimensions && dimensions.contentWidth,
      margin: dimensions && "0 " + (dimensions.containerWidth - dimensions.contentWidth) / 2 + "px",
      transform: "scale(" + scale + ")",
      transformOrigin: "center " + verticalOrigin + "px"
    })
  }, React__default.createElement("div", {
    style: {
      height: dimensions && dimensions.containerHeight / 2
    }
  }), linesCtx.map(function (ctx, key) {
    return React__default.createElement(Line, {
      ctx: ctx,
      key: key
    });
  }), React__default.createElement("div", {
    style: {
      height: dimensions && dimensions.containerHeight / 2
    }
  })));
}

function Line(_ref3) {
  var ctx = _ref3.ctx;
  var lineStyle = ctx.animations([].concat(heightChangingAnimations, [{
    animation: focusLine
  }]));

  var _ctx$animate2 = ctx.animate(function (prev, next) {
    var line = prev || next;
    return {
      lineTokens: line.tokens,
      key: line.key,
      focusPerToken: prev && prev.focusPerToken || next && next.focusPerToken
    };
  }),
      lineTokens = _ctx$animate2.lineTokens,
      key = _ctx$animate2.key,
      focusPerToken = _ctx$animate2.focusPerToken;

  var getStyleForToken = useTokenStyles();
  var tokens = [];
  var tokensCtx = ctx.useSelectMany(function (line) {
    return line.tokens;
  });

  if (focusPerToken) {
    tokens = tokensCtx.map(function (tokenCtx) {
      return _extends({}, tokenCtx.animate(function (prev, next) {
        return prev || next;
      }), {
        animatedStyle: tokenCtx.animate(focusToken)
      });
    });
  } else {
    tokens = lineTokens.map(function (token) {
      return _extends({}, token, {
        animatedStyle: {}
      });
    });
  }

  return React__default.createElement("div", {
    style: _extends({
      overflow: "hidden"
    }, lineStyle)
  }, React__default.createElement("div", {
    style: {
      display: "inline-block"
    },
    className: "cs-line cs-line-" + key
  }, tokens.map(function (token, i) {
    return React__default.createElement("span", {
      key: i,
      style: _extends({}, getStyleForToken(token), token.animatedStyle)
    }, token.content);
  })));
}

function Title(_ref4) {
  var ctx = _ref4.ctx;
  var text = ctx.animate(switchText);
  var bgStyle = ctx.animate(fadeBackground);
  var textStyle = ctx.animate(fadeText);
  if (!text) return null;
  return React__default.createElement("h4", {
    className: "cs-title",
    style: _extends({}, useTitleStyle(), bgStyle)
  }, React__default.createElement("span", {
    style: textStyle
  }, text));
}

function Subtitle(_ref5) {
  var ctx = _ref5.ctx;
  var text = ctx.animate(switchText);
  var bgStyle = ctx.animate(fadeBackground);
  var textStyle = ctx.animate(fadeText);
  if (!text) return null;
  return React__default.createElement("p", {
    className: "cs-subtitle",
    style: _extends({}, useSubtitleStyle(), bgStyle)
  }, React__default.createElement("span", {
    style: textStyle
  }, text));
}

var fadeBackground = function fadeBackground(prev, next, t) {
  var opacity = 1;

  if (!prev) {
    opacity = t;
  }

  if (!next) {
    opacity = 1 - t;
  }

  return {
    opacity: opacity
  };
};

var fadeText = function fadeText(prev, next, t) {
  if (prev && next && prev.value !== next.value) {
    return fadeOutIn(t);
  }

  if (!prev) {
    return fadeIn(t);
  }

  if (!next) {
    return fadeOut(t);
  }

  return {
    opacity: 1
  };
};

function useWindowResize(handler, deps) {
  React__default.useEffect(function () {
    window.addEventListener("resize", handler);
    return function () {
      window.removeEventListener("resize", handler);
    };
  }, deps);
}

function useDimensions(ref, steps) {
  var _React$useState = React__default.useState(null),
      result = _React$useState[0],
      setResult = _React$useState[1];

  useWindowResize(function () {
    return setResult(null);
  }, [setResult]);
  React__default.useLayoutEffect(function () {
    if (!ref.current) return;
    if (result) return;
    var containers = ref.current.querySelectorAll(".cs-container");
    var stepsDimensions = Array.from(containers).map(function (container, i) {
      return getStepDimensions(container, steps[i]);
    });
    var containerHeight = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.containerHeight;
    }));
    var containerWidth = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.containerWidth;
    }));
    var contentWidth = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.contentWidth;
    }));
    var lineHeight = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.lineHeight;
    }));
    setResult({
      dimensions: {
        lineHeight: lineHeight,
        contentWidth: contentWidth,
        containerHeight: containerHeight,
        containerWidth: containerWidth
      },
      steps: steps.map(function (step, i) {
        return _extends({}, step, {
          lines: step.lines.map(function (l) {
            return _extends({}, l, {
              dimensions: {
                lineHeight: stepsDimensions[i].lineHeight
              }
            });
          }),
          dimensions: {
            paddingTop: stepsDimensions[i].paddingTop,
            paddingBottom: stepsDimensions[i].paddingBottom,
            lineHeight: stepsDimensions[i].lineHeight,
            contentWidth: contentWidth,
            containerHeight: containerHeight,
            containerWidth: containerWidth
          }
        });
      })
    });
  }, [result]);
  return result || {};
}

function getStepDimensions(container, step) {
  var longestLine = getLongestLine(step);
  var longestLineKey = longestLine && longestLine.key;
  var longestLineSpan = container.querySelector(".cs-line-" + longestLineKey);
  var containerParent = container.parentElement;
  var title = container.querySelector(".cs-title");
  var subtitle = container.querySelector(".cs-subtitle");
  var lineCount = step.lines.length;
  var heightOverflow = containerParent.scrollHeight - containerParent.clientHeight;
  var avaliableHeight = container.scrollHeight - heightOverflow;
  var lineHeight = longestLineSpan ? longestLineSpan.clientHeight : 0;
  var paddingTop = title ? outerHeight(title) : lineHeight;
  var paddingBottom = subtitle ? outerHeight(subtitle) : lineHeight;
  var codeHeight = lineCount * lineHeight * 2; // const maxContentHeight = codeHeight + paddingTop + paddingBottom;
  // const containerHeight = Math.min(maxContentHeight, avaliableHeight);

  var containerHeight = avaliableHeight;
  var containerWidth = container.clientWidth;
  var contentHeight = codeHeight + containerHeight;
  var contentWidth = longestLineSpan ? longestLineSpan.clientWidth : 0;
  return {
    lineHeight: lineHeight,
    contentHeight: contentHeight,
    contentWidth: contentWidth,
    paddingTop: paddingTop,
    paddingBottom: paddingBottom,
    containerHeight: containerHeight,
    containerWidth: containerWidth
  };
}

function outerHeight(element) {
  var styles = window.getComputedStyle(element);
  var margin = parseFloat(styles["marginTop"] || "0") + parseFloat(styles["marginBottom"] || "0");
  return element.offsetHeight + margin;
}

function getLongestLine(step) {
  if (!step || step.lines.length === 0) {
    return null;
  }

  return step.lines.reduce(function (a, b) {
    return a.content.length > b.content.length ? a : b;
  });
}

function CodeSurfer(_ref) {
  var progress = _ref.progress,
      inputSteps = _ref.steps,
      theme = _ref.theme;
  var steps = parseSteps(inputSteps, inputSteps[0].lang || "javascript"); // const stepIndex = Math.round(progress);

  var ref = React__default.useRef(null);

  var _useDimensions = useDimensions(ref, steps),
      dimensions = _useDimensions.dimensions,
      stepsWithDimensions = _useDimensions.steps;

  if (!dimensions) {
    return React__default.createElement(ThemeContext.Provider, {
      value: theme
    }, React__default.createElement("div", {
      ref: ref,
      style: {
        overflow: "auto",
        height: "100%",
        width: "100%"
      }
    }, steps.map(function (_step, i) {
      return React__default.createElement("div", {
        key: i,
        style: {
          overflow: "auto",
          height: "100%",
          width: "100%"
        }
      }, React__default.createElement(CodeSurferContainer, {
        steps: steps,
        stepPlayhead: i
      }));
    })));
  } else {
    return React__default.createElement(ThemeContext.Provider, {
      value: theme
    }, React__default.createElement("div", {
      style: {
        height: "100%",
        width: "100%",
        overflow: "auto"
      },
      ref: ref
    }, React__default.createElement(CodeSurferContainer, {
      steps: stepsWithDimensions,
      stepPlayhead: progress,
      dimensions: dimensions
    })));
  }
}

/**
 * The metastring is the thing that comes after the language in markdown codeblocks
 *
 * ```js this is the metastring
 * code goes here
 * ```
 */

function parseMetastring(metastring) {
  if (!metastring) {
    return {};
  }

  var argv = shellQuote.parse(metastring);
  var result = {};
  argv.forEach(function (arg) {
    if (!arg.includes("=")) {
      result.focus = arg;
    } else {
      var _arg$split = arg.split(/=(.*)/),
          key = _arg$split[0],
          value = _arg$split[1];

      result[key] = {
        value: value
      };
    }
  });
  return result;
}

function readStepFromElement(element) {
  if (element.type === Code) {
    // wrap everything except [code, lang, focus] in {value}
    var stepEntries = Object.entries(element.props).map(function (_ref) {
      var _ref2;

      var key = _ref[0],
          value = _ref[1];
      return _ref2 = {}, _ref2[key] = ["code", "focus", "lang"].includes(key) ? value : {
        value: value
      }, _ref2;
    });
    return Object.assign.apply(Object, [{}].concat(stepEntries));
  }

  if (!element.props.children || !element.props.children.props) {
    return null;
  }

  var props = element.props.children.props;
  var classNames = props.className;
  return _extends({
    code: props.children,
    lang: classNames && classNames[0].substring("language-".length)
  }, parseMetastring(props.metastring));
}

var ErrorBoundary =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {};
    return _this;
  }

  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error, info) {// console.log(error, info);
  };

  _proto.render = function render() {
    if (!this.state.error) {
      return this.props.children;
    } else if (this.state.error.element) {
      return this.state.error.element;
    } else {
      console.error(this.state.error);
      return React__default.createElement(UnknownError, {
        error: this.state.error
      });
    }
  };

  return ErrorBoundary;
}(React__default.Component);

function useNotes(notesElements) {
  var context = mdxDeck.useDeck();
  React__default.useEffect(function () {
    if (!context || !context.register) return;
    if (typeof context.index === "undefined") return;
    var notes = getNotesFromElements(notesElements);
    context.register(context.index, {
      notes: notes
    });
  }, []);
}

function getNotesFromElements(notesElements) {
  var notes = notesElements.map(function (element) {
    if (!element) {
      // this is a step with empty notes
      return null;
    }

    var props = element.props;

    if (props.inline) {
      // this is <Notes inline={true} />
      return {
        inline: true,
        text: props.children
      };
    } // this is <Notes>something</Notes>
    // we shouldn't return an object here,
    // to be compatible with the default Presenter


    return props && props.children;
  });

  if (notes.length) {
    var lastNotes = notes[notes.length - 1]; // we add an extra EOL to the last step

    notes[notes.length - 1] = (lastNotes || "") + "\n";
  }

  return notes;
}

function getTextFromNotes(notes) {
  if (notes === null) {
    // this is a step with empty notes
    // we don't add extra lines here
    // to allow a line of text with multiple notes
    return "";
  }

  if (typeof notes === "object") {
    // this comes from a step with inline=true
    // but we check again just in case
    return notes.text + (notes.inline ? "" : "\n");
  } else {
    // this could be an empty note from any slide
    // or a note from a step without the inline prop
    return notes + "\n";
  }
}

function useSteps (stepsCount) {
  var step = mdxDeck.useSteps(stepsCount);
  return step === Infinity ? 0 : step;
}

// based on https://github.com/streamich/react-use/blob/master/src/useSpring.ts
function useSpring(_ref) {
  var _ref$target = _ref.target,
      target = _ref$target === void 0 ? 0 : _ref$target,
      _ref$current = _ref.current,
      current = _ref$current === void 0 ? null : _ref$current,
      _ref$tension = _ref.tension,
      tension = _ref$tension === void 0 ? 0 : _ref$tension,
      _ref$friction = _ref.friction,
      friction = _ref$friction === void 0 ? 13 : _ref$friction,
      _ref$round = _ref.round,
      round = _ref$round === void 0 ? function (x) {
    return x;
  } : _ref$round;

  var _useState = React.useState(null),
      spring = _useState[0],
      setSpring = _useState[1];

  var _useState2 = React.useState(target),
      value = _useState2[0],
      setValue = _useState2[1];

  React.useEffect(function () {
    var listener = {
      onSpringUpdate: function onSpringUpdate(spring) {
        var value = spring.getCurrentValue();
        setValue(round(value));
      }
    };

    if (!spring) {
      var newSpring = new rebound.SpringSystem().createSpring(tension, friction);
      newSpring.setCurrentValue(target);
      setSpring(newSpring);
      newSpring.addListener(listener);
      return;
    }

    return function () {
      spring.removeListener(listener);
      setSpring(null);
    };
  }, [tension, friction]);
  React.useEffect(function () {
    if (spring) {
      spring.setEndValue(target);

      if (current != null) {
        spring.setCurrentValue(current);
      }
    }
  }, [target, current]);
  return value;
}

function useStepSpring(stepsCount) {
  // step index according to mdx-deck
  var targetStepIndex = useSteps(stepsCount - 1); // real number between 0 and stepsCount - 1

  var currentStepSpring = useSpring({
    target: targetStepIndex,
    round: function round(x) {
      return Math.round(x * 1000) / 1000;
    }
  });
  return currentStepSpring;
}

function CodeSurferLayout(_ref) {
  var children = _ref.children;
  var deck = mdxDeck.useDeck();
  var steps = React__default.useMemo(getStepsFromChildren(children), [deck.index]);
  useNotes(steps.map(function (s) {
    return s.notesElement;
  }));
  var progress = useStepSpring(steps.length);
  var theme = mdxDeck.useTheme();
  return React__default.createElement("div", {
    style: {
      width: "100vw",
      maxWidth: "100%",
      height: "100vh",
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center"
    },
    className: "cs-layout"
  }, React__default.createElement(CodeSurfer, {
    steps: steps,
    progress: progress,
    theme: theme.codeSurfer
  }));
}

var getStepsFromChildren = function getStepsFromChildren(children) {
  return function () {
    var kids = React__default.Children.toArray(children);
    return kids.map(function (child, i) {
      var step = readStepFromElement(child);
      if (!step) return;
      var nextChild = kids[i + 1];

      if (nextChild && nextChild.type === mdxDeck.Notes) {
        step.notesElement = nextChild;
      }

      return step;
    }).filter(function (x) {
      return x;
    });
  };
};

var layout = (function (props) {
  return React__default.createElement(ErrorBoundary, null, React__default.createElement(CodeSurferLayout, Object.assign({}, props)));
});

function ColumnLayout(_ref) {
  var children = _ref.children,
      _ref$themes = _ref.themes,
      themes = _ref$themes === void 0 ? [] : _ref$themes,
      sizes = _ref.sizes;
  var deck = mdxDeck.useDeck();

  var _React$useMemo = React__default.useMemo(function () {
    return getColumnsFromChildren(children, sizes);
  }, [deck.index]),
      columns = _React$useMemo[0],
      titles = _React$useMemo[1],
      subtitles = _React$useMemo[2],
      notesElements = _React$useMemo[3];

  useNotes(notesElements);
  var progress = useStepSpring(columns[0].steps.length);
  var stepIndex = Math.round(progress);
  var theme = mdxDeck.useTheme();
  return React__default.createElement("div", {
    style: {
      width: "100vw",
      maxWidth: "100%",
      height: "100vh",
      display: "flex",
      flexDirection: "row",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "0.8em",
      position: "relative"
    },
    className: "cs-col-layout"
  }, columns.map(function (column, i) {
    return React__default.createElement(Column, {
      key: i,
      column: column,
      progress: progress,
      theme: themes[i] ? themes[i].codeSurfer : theme.codeSurfer
    });
  }), React__default.createElement(ThemeContext.Provider, {
    value: theme.codeSurfer
  }, React__default.createElement(Title$1, {
    text: titles[stepIndex]
  }), React__default.createElement(Subtitle$1, {
    text: subtitles[stepIndex]
  })));
}

function Column(_ref2) {
  var column = _ref2.column,
      progress = _ref2.progress,
      theme = _ref2.theme;
  return React__default.createElement("div", {
    style: {
      flex: column.flex,
      overflow: "hidden",
      height: "100%"
    }
  }, column.isCode ? React__default.createElement(CodeSurfer, {
    steps: column.steps,
    progress: progress,
    theme: theme
  }) : column.steps[Math.round(progress)].element);
}

function Title$1(_ref3) {
  var text = _ref3.text;
  if (!text) return null;
  return React__default.createElement("h4", {
    className: "cs-title",
    style: useTitleStyle()
  }, React__default.createElement("span", null, text));
}

function Subtitle$1(_ref4) {
  var text = _ref4.text;
  if (!text) return null;
  return React__default.createElement("p", {
    className: "cs-subtitle",
    style: _extends({}, useSubtitleStyle(), {
      margin: "0.3em 0"
    })
  }, React__default.createElement("span", null, text));
}

function getColumnsFromChildren(children, sizes) {
  if (sizes === void 0) {
    sizes = [];
  }

  var columns = [];
  var stepElements = React__default.Children.toArray(children);
  stepElements.forEach(function (stepElement, stepIndex) {
    React__default.Children.toArray(stepElement.props.children).filter(function (element) {
      return element.type !== mdxDeck.Notes;
    }).forEach(function (codeElement, columnIndex) {
      columns[columnIndex] = columns[columnIndex] || {
        steps: [],
        isCode: true
      };
      var step = readStepFromElement(codeElement);
      columns[columnIndex].isCode = columns[columnIndex].isCode && step;
      columns[columnIndex].steps[stepIndex] = step || {
        element: codeElement
      };
    });
  });
  columns.forEach(function (column, columnIndex) {
    column.flex = sizes[columnIndex] || 1;
  });
  var titles = stepElements.map(function (stepElement) {
    return stepElement.props.title;
  });
  var subtitles = stepElements.map(function (stepElement) {
    return stepElement.props.subtitle;
  });
  var notesElements = stepElements.map(function (stepElement) {
    var stepChildren = React__default.Children.toArray(stepElement.props.children);
    var notesElement = stepChildren.find(function (element) {
      return element.type === mdxDeck.Notes;
    });
    return notesElement;
  });
  return [columns, titles, subtitles, notesElements];
}

var columnLayout = (function (props) {
  return React__default.createElement(ErrorBoundary, null, React__default.createElement(ColumnLayout, Object.assign({}, props)));
});

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n          .ekm8v3h0,\n          .cs-layout,\n          cs-col-layout {\n            height: ", "px !important;\n          }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var Teleprompter = function Teleprompter(_ref) {
  var index = _ref.index,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["index", "children"]);

  var ref = React__default.useRef(null);

  var _React$useState = React__default.useState(0),
      target = _React$useState[0],
      setTarget = _React$useState[1];

  var scrollTop = useSpring({
    target: target,
    friction: 25
  });
  React__default.useEffect(function () {
    var self = ref.current;
    var child = self.children[index + 1];
    var childTop = child.offsetTop - self.offsetTop;
    var childHeight = child.getBoundingClientRect().height;
    var selfHeight = self.getBoundingClientRect().height;

    if (childHeight) {
      setTarget(childTop - selfHeight / 2 + childHeight / 2);
    }
  }, [index]);
  React__default.useLayoutEffect(function () {
    ref.current.scrollTop = scrollTop;
  }, [scrollTop]);
  return React__default.createElement("div", Object.assign({}, rest, {
    ref: ref
  }), React__default.createElement("div", {
    style: {
      height: "50%"
    }
  }), children, React__default.createElement("div", {
    style: {
      height: "50%"
    }
  }));
};

function AllSlides(_ref2) {
  var context = _ref2.context,
      slides = _ref2.slides,
      style = _ref2.style;
  return React__default.createElement("div", {
    style: style
  }, slides.map(function (Component, i) {
    return React__default.createElement(mdxDeck.Slide, {
      key: i,
      context: _extends({}, context, {
        index: i
      }),
      index: i
    }, React__default.createElement(Component, null));
  }));
}

function MobilePresenter(_ref3) {
  var allNotes = _ref3.allNotes,
      noteIndex = _ref3.noteIndex,
      children = _ref3.children,
      windowWidth = _ref3.windowWidth,
      previous = _ref3.previous,
      next = _ref3.next,
      slides = _ref3.slides,
      index = _ref3.index;
  var ratio = 16 / 9;
  var deckHeight = windowWidth / ratio;
  var windowHeight = window.innerHeight;
  var separatorHeight = 6;
  var notesHeight = windowHeight - deckHeight - separatorHeight;

  var _useTheme = mdxDeck.useTheme(),
      colors = _useTheme.colors;

  var progress = 100 * (index + 1) / slides.length;
  return React__default.createElement("div", {
    className: "presenter",
    style: {
      display: "flex",
      flexDirection: "column",
      height: windowHeight,
      background: colors.background,
      overflow: "hidden"
    }
  }, React__default.createElement(core.Global, {
    styles: core.css(_templateObject(), deckHeight)
  }), React__default.createElement("div", {
    style: {
      height: deckHeight
    }
  }, children), React__default.createElement("div", {
    style: {
      height: separatorHeight,
      background: colors.link,
      opacity: 0.7,
      boxShadow: "2px 2px 2px 1px rgba(0, 0, 0, 0.25)"
    }
  }, React__default.createElement("div", {
    style: {
      height: "100%",
      width: 100 - progress + "%",
      opacity: 0.5,
      "float": "right",
      background: "#444"
    }
  })), React__default.createElement("div", {
    style: {
      height: notesHeight
    }
  }, React__default.createElement(reactSwipeable.Swipeable, {
    onSwipedRight: previous,
    onSwipedLeft: next,
    onSwipedDown: previous,
    onSwipedUp: next,
    style: {
      height: "100%"
    }
  }, React__default.createElement(Teleprompter, {
    index: noteIndex,
    style: {
      color: colors.text,
      whiteSpace: "pre-wrap",
      overflow: "hidden",
      height: "100%",
      width: "90%",
      margin: "0px auto"
    },
    onClick: next
  }, allNotes.map(function (note, i) {
    return React__default.createElement("span", {
      style: {
        opacity: noteIndex === i ? 1 : 0.5
      },
      key: i
    }, note.notes);
  })))));
}

function DesktopPresenter(_ref4) {
  var slides = _ref4.slides,
      index = _ref4.index,
      allNotes = _ref4.allNotes,
      noteIndex = _ref4.noteIndex,
      children = _ref4.children;
  return React__default.createElement("div", {
    style: {
      color: "#fafafa",
      backgroundColor: "#222",
      display: "flex",
      height: "100vh",
      width: "100vw"
    }
  }, React__default.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      padding: "10px",
      boxSizing: "border-box"
    }
  }, React__default.createElement(mdxDeck.Zoom, {
    zoom: 5 / 8
  }, children), React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "100%",
      padding: "0 16px",
      background: "#333"
    }
  }, React__default.createElement("pre", null, "Slide ", index + 1, " of ", slides.length), React__default.createElement(mdxDeck.Clock, null)), React__default.createElement("a", {
    target: "_blank",
    rel: "noopener noreferrer",
    href: router.globalHistory.location.origin + router.globalHistory.location.pathname,
    style: {
      color: "#bbb",
      padding: "10px"
    }
  }, "Open Slides in New Window")), React__default.createElement("div", {
    style: {
      height: "100%",
      boxSizing: "border-box"
    }
  }, React__default.createElement(Teleprompter, {
    index: noteIndex,
    style: {
      color: "#FFFF33",
      whiteSpace: "pre-wrap",
      overflow: "hidden",
      height: "100%",
      width: "90%",
      margin: "5px auto"
    }
  }, allNotes.map(function (note, i) {
    return React__default.createElement("span", {
      style: {
        opacity: noteIndex === i ? 1 : 0.5
      },
      key: i
    }, note.notes);
  }))));
}

var Presenter = function Presenter(props) {
  var slides = props.slides,
      metadata = props.metadata,
      index = props.index,
      step = props.step,
      children = props.children,
      previous = props.previous,
      next = props.next;
  var windowWidth = useWindowWidth();

  var _React$useState2 = React__default.useState(false),
      areNotesReady = _React$useState2[0],
      setNotesReady = _React$useState2[1];

  React__default.useEffect(function () {
    setNotesReady(true);
  }, []);
  var allNotes = React__default.useMemo(function () {
    return slides.flatMap(function (slide, slideIndex) {
      var _ref5 = metadata[slideIndex] || {
        notes: ""
      },
          slideNotes = _ref5.notes;

      if (Array.isArray(slideNotes)) {
        return slideNotes.map(function (stepNotes, stepIndex) {
          return {
            notes: getTextFromNotes(stepNotes),
            slideIndex: slideIndex,
            stepIndex: stepIndex
          };
        });
      } else {
        return {
          notes: getTextFromNotes(slideNotes),
          slideIndex: slideIndex,
          stepIndex: "any"
        };
      }
    });
  }, [areNotesReady]);
  var noteIndex = allNotes.findIndex(function (stepNotes) {
    return stepNotes.slideIndex === index && (stepNotes.stepIndex === "any" || stepNotes.stepIndex === step);
  });
  return React__default.createElement(React__default.Fragment, null, !areNotesReady && // Need to render all slides to run the effects that set the notes
  React__default.createElement(AllSlides, {
    style: {
      display: "none"
    },
    context: props,
    slides: slides
  }), windowWidth > 700 ? React__default.createElement(DesktopPresenter, Object.assign({}, {
    allNotes: allNotes,
    index: index,
    slides: slides,
    noteIndex: noteIndex,
    children: children
  })) : React__default.createElement(MobilePresenter, Object.assign({}, {
    allNotes: allNotes,
    index: index,
    slides: slides,
    noteIndex: noteIndex,
    children: children,
    windowWidth: windowWidth,
    previous: previous,
    next: next
  })));
};

function useWindowWidth() {
  var _React$useState3 = React__default.useState(window && window.innerWidth),
      width = _React$useState3[0],
      changeWidth = _React$useState3[1];

  React__default.useEffect(function () {
    var handleResize = function handleResize() {
      return changeWidth(window.innerWidth);
    };

    window.addEventListener("resize", handleResize);
    return function () {
      return window.removeEventListener("resize", handleResize);
    };
  }, [changeWidth]);
  return width;
}

function mdThemes(theme) {
  var stringStyle = theme.styles.find(function (s) {
    return s.types.includes("string");
  });
  var color = theme.pre.color;
  var bg = theme.pre.background;
  return [{
    codeSurfer: theme
  }, {
    colors: {
      text: color,
      background: bg,
      link: stringStyle && stringStyle.style.color,
      pre: color,
      code: color,
      preBackground: bg
    },
    Presenter: Presenter,
    codeSurfer: theme
  }];
}

var _mdThemes =
/*#__PURE__*/
mdThemes(theme$1),
    draculaPartial = _mdThemes[0],
    dracula = _mdThemes[1];

var _mdThemes2 =
/*#__PURE__*/
mdThemes(theme$3),
    duotoneLightPartial = _mdThemes2[0],
    duotoneLight = _mdThemes2[1];

var _mdThemes3 =
/*#__PURE__*/
mdThemes(theme$2),
    duotoneDarkPartial = _mdThemes3[0],
    duotoneDark = _mdThemes3[1];

var _mdThemes4 =
/*#__PURE__*/
mdThemes(theme),
    githubPartial = _mdThemes4[0],
    github = _mdThemes4[1];

var _mdThemes5 =
/*#__PURE__*/
mdThemes(theme$4),
    nightOwlPartial = _mdThemes5[0],
    nightOwl = _mdThemes5[1];

var _mdThemes6 =
/*#__PURE__*/
mdThemes(theme$5),
    oceanicNextPartial = _mdThemes6[0],
    oceanicNext = _mdThemes6[1];

var _mdThemes7 =
/*#__PURE__*/
mdThemes(theme$6),
    shadesOfPurplePartial = _mdThemes7[0],
    shadesOfPurple = _mdThemes7[1];

var _mdThemes8 =
/*#__PURE__*/
mdThemes(theme$7),
    ultraminPartial = _mdThemes8[0],
    ultramin = _mdThemes8[1];

var _mdThemes9 =
/*#__PURE__*/
mdThemes(theme$8),
    vsDarkPartial = _mdThemes9[0],
    vsDark = _mdThemes9[1];

exports.Code = Code;
exports.CodeSurferColumnLayout = columnLayout;
exports.CodeSurferLayout = layout;
exports.Step = Step;
exports.dracula = dracula;
exports.draculaPartial = draculaPartial;
exports.duotoneDark = duotoneDark;
exports.duotoneDarkPartial = duotoneDarkPartial;
exports.duotoneLight = duotoneLight;
exports.duotoneLightPartial = duotoneLightPartial;
exports.github = github;
exports.githubPartial = githubPartial;
exports.nightOwl = nightOwl;
exports.nightOwlPartial = nightOwlPartial;
exports.oceanicNext = oceanicNext;
exports.oceanicNextPartial = oceanicNextPartial;
exports.shadesOfPurple = shadesOfPurple;
exports.shadesOfPurplePartial = shadesOfPurplePartial;
exports.ultramin = ultramin;
exports.ultraminPartial = ultraminPartial;
exports.vsDark = vsDark;
exports.vsDarkPartial = vsDarkPartial;
//# sourceMappingURL=code-surfer.cjs.development.js.map
