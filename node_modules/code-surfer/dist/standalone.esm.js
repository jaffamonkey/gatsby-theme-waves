import React from 'react';
import { applyPatch, diffLines } from 'diff';
import Prism from 'prismjs';
import flat from 'array.prototype.flat';
import 'prismjs/components/prism-markup';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-css-extras';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-js-extras';
import 'prismjs/components/prism-coffeescript';
import 'prismjs/components/prism-diff';
import 'prismjs/components/prism-git';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-graphql';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-less';
import 'prismjs/components/prism-makefile';
import 'prismjs/components/prism-markdown';
import 'prismjs/components/prism-objectivec';
import 'prismjs/components/prism-ocaml';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-reason';
import 'prismjs/components/prism-sass';
import 'prismjs/components/prism-scss';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-stylus';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-wasm';
import 'prismjs/components/prism-yaml';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function grammarNotFound(_ref2) {
  var lang = _ref2.lang;
  return {
    element: React.createElement(ErrorBox, {
      header: "Oops, there's a problem",
      body: React.createElement(React.Fragment, null, "Syntax highlighter for ", React.createElement(Mark, null, "\"", lang, "\""), " not found.", React.createElement("p", null, "You can try importing it from prismjs with: ", React.createElement("br", null), React.createElement(Mark, null, "import \"prismjs/components/prism-", lang, "\"")), "(See", " ", React.createElement("a", {
        href: "https://prismjs.com/#supported-languages",
        style: {
          color: "grey"
        }
      }, "all the supported languages"), ")")
    })
  };
}
function invalidFocusNumber(n) {
  return {
    withFocusString: function withFocusString(focusString) {
      return {
        withStepIndex: function withStepIndex(stepIndex) {
          return {
            element: React.createElement(ErrorBox, {
              header: React.createElement(StepErrorHeader, {
                stepIndex: stepIndex
              }),
              body: React.createElement(React.Fragment, null, React.createElement(Mark, null, "\"", n, "\""), " isn't a valid number", " ", n != focusString && React.createElement(Mark, null, " (in \"", focusString, "\")"))
            })
          };
        }
      };
    }
  };
}
function invalidLineOrColumnNumber() {
  return {
    withFocusString: function withFocusString(focusString) {
      return {
        withStepIndex: function withStepIndex(stepIndex) {
          return {
            element: React.createElement(ErrorBox, {
              header: React.createElement(StepErrorHeader, {
                stepIndex: stepIndex
              }),
              body: React.createElement(React.Fragment, null, "Are you using \"0\" as a line or column number", " ", React.createElement(Mark, null, "in \"", focusString, "\""), "?", React.createElement("br", null), "(Line and column numbers should start at 1, not 0) ", React.createElement("br", null))
            })
          };
        }
      };
    }
  };
}

function ErrorBox(_ref3) {
  var header = _ref3.header,
      body = _ref3.body;
  return React.createElement("div", {
    style: {
      background: "#290000",
      color: "#b96f70",
      border: "2px solid #b96f70",
      padding: "10px 30px",
      maxWidth: "90vw",
      margin: "0 auto",
      fontFamily: "monospace",
      fontSize: "1rem"
    }
  }, React.createElement("h3", null, header), React.createElement("p", null, body));
}

function StepErrorHeader(_ref4) {
  var stepIndex = _ref4.stepIndex;
  return React.createElement(React.Fragment, null, "Oops, there's a problem with the", " ", React.createElement(Mark, null, stepIndex + 1, React.createElement("sup", null, ordinal(stepIndex + 1)), " step"));
}

function Mark(_ref5) {
  var children = _ref5.children;
  return React.createElement("mark", {
    style: {
      background: "none",
      color: "pink",
      fontWeight: "bolder"
    }
  }, children);
}

function ordinal(i) {
  var j = i % 10,
      k = i % 100;

  if (j == 1 && k != 11) {
    return "st";
  }

  if (j == 2 && k != 12) {
    return "nd";
  }

  if (j == 3 && k != 13) {
    return "rd";
  }

  return "th";
}

var newlineRe = /\r\n|\r|\n/; // Take a list of nested tokens
// (token.content may contain an array of tokens)
// and flatten it so content is always a string
// and type the type of the leaf

function flattenTokens(tokens) {
  var flatList = [];
  tokens.forEach(function (token) {
    var type = token.type,
        content = token.content;

    if (Array.isArray(content)) {
      flatList.push.apply(flatList, flattenTokens(content));
    } else {
      flatList.push({
        type: type,
        content: content
      });
    }
  });
  return flatList;
}

function wrapToken(prismToken, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  if (typeof prismToken === "string") {
    return {
      type: parentType,
      content: prismToken
    };
  }

  if (Array.isArray(prismToken.content)) {
    return {
      type: prismToken.type,
      content: tokenizeStrings(prismToken.content, prismToken.type)
    };
  }

  return wrapToken(prismToken.content, prismToken.type);
} // Wrap strings in tokens


function tokenizeStrings(prismTokens, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  return prismTokens.map(function (prismToken) {
    return wrapToken(prismToken, parentType);
  });
}

function tokenize(code, language) {
  if (language === void 0) {
    language = "javascript";
  }

  var grammar = Prism.languages[language];

  if (!grammar) {
    throw grammarNotFound({
      lang: language
    });
  }

  var prismTokens = Prism.tokenize(code, Prism.languages[language]);
  var nestedTokens = tokenizeStrings(prismTokens);
  var tokens = flattenTokens(nestedTokens);
  var currentLine = [];
  var lines = [currentLine];
  tokens.forEach(function (token) {
    var contentLines = token.content.split(newlineRe);
    var firstContent = contentLines.shift();

    if (firstContent !== undefined && firstContent !== "") {
      currentLine.push({
        type: token.type,
        content: firstContent
      });
    }

    contentLines.forEach(function (content) {
      currentLine = [];
      lines.push(currentLine);

      if (content !== "") {
        currentLine.push({
          type: token.type,
          content: content
        });
      }
    });
  });
  return lines;
}

var newlineRe$1 = /\r\n|\r|\n/;

function myDiff(oldCode, newCode) {
  var changes = diffLines(oldCode || "", newCode);
  var oldIndex = -1;
  return changes.map(function (_ref) {
    var value = _ref.value,
        count = _ref.count,
        removed = _ref.removed,
        added = _ref.added;
    var lines = value.split(newlineRe$1); // check if last line is empty, if it is, remove it

    var lastLine = lines.pop();

    if (lastLine) {
      lines.push(lastLine);
    }

    var result = {
      oldIndex: oldIndex,
      lines: lines,
      count: count,
      removed: removed,
      added: added
    };

    if (!added) {
      oldIndex += count || 0;
    }

    return result;
  });
}

function insert(array, index, elements) {
  return array.splice.apply(array, [index, 0].concat(elements));
}

function slideDiff(lines, codes, slideIndex, language) {
  var prevLines = lines.filter(function (l) {
    return l.slides.includes(slideIndex - 1);
  });
  var prevCode = codes[slideIndex - 1] || "";
  var currCode = codes[slideIndex];
  var changes = myDiff(prevCode, currCode);
  changes.forEach(function (change) {
    if (change.added) {
      var prevLine = prevLines[change.oldIndex];
      var addAtIndex = lines.indexOf(prevLine) + 1;
      var addLines = change.lines.map(function (content) {
        return {
          content: content,
          slides: [slideIndex],
          tokens: []
        };
      });
      insert(lines, addAtIndex, addLines);
    } else if (!change.removed) {
      for (var j = 1; j <= (change.count || 0); j++) {
        prevLines[change.oldIndex + j].slides.push(slideIndex);
      }
    }
  });
  var tokenLines = tokenize(currCode, language);
  var currLines = lines.filter(function (l) {
    return l.slides.includes(slideIndex);
  });
  currLines.forEach(function (line, index) {
    return line.tokens = tokenLines[index];
  });
}

function parseLines(codes, language) {
  var lines = [];

  for (var slideIndex = 0; slideIndex < codes.length; slideIndex++) {
    slideDiff(lines, codes, slideIndex, language);
  }

  return lines;
}
function getSlides(codes, language) {
  // codes are in reverse cronological order
  var lines = parseLines(codes, language); // console.log("lines", lines);

  return codes.map(function (_, slideIndex) {
    return lines.map(function (line, lineIndex) {
      return {
        content: line.content,
        tokens: line.tokens,
        isNew: !line.slides.includes(slideIndex + 1),
        show: line.slides.includes(slideIndex),
        key: lineIndex
      };
    }).filter(function (line) {
      return line.show;
    });
  });
}
function getCodes(rawSteps) {
  var codes = [];
  rawSteps.forEach(function (s, i) {
    if (s.lang === "diff" && i > 0) {
      codes[i] = applyPatch(codes[i - 1], s.code);
    } else {
      codes[i] = s.code;
    }
  });
  return codes;
}

function parseFocus(focus) {
  if (!focus) {
    throw new Error("Focus cannot be empty");
  }

  try {
    var parts = focus.split(/,(?![^\[]*\])/g).map(parsePart);
    return new Map(flat(parts));
  } catch (error) {
    if (error.withFocusString) {
      throw error.withFocusString(focus);
    } else {
      throw error;
    }
  }
}

function parsePart(part) {
  // a part could be
  // - a line number: "2"
  // - a line range: "5:9"
  // - a line number with a column selector: "2[1,3:5,9]"
  var columnsMatch = part.match(/(\d+)\[(.+)\]/);

  if (columnsMatch) {
    var line = columnsMatch[1],
        columns = columnsMatch[2];
    var columnsList = columns.split(",").map(expandString);
    var lineIndex = Number(line) - 1;
    var columnIndexes = flat(columnsList).map(function (c) {
      return c - 1;
    });
    return [[lineIndex, columnIndexes]];
  } else {
    return expandString(part).map(function (lineNumber) {
      return [lineNumber - 1, true];
    });
  }
}

function expandString(part) {
  // Transforms something like
  // - "1:3" to [1,2,3]
  // - "4" to [4]
  var _part$split = part.split(":"),
      start = _part$split[0],
      end = _part$split[1]; // todo check if start is 0, line numbers and column numbers start at 1


  if (!isNaturalNumber(start)) {
    throw invalidFocusNumber(start);
  }

  var startNumber = Number(start);

  if (startNumber < 1) {
    throw invalidLineOrColumnNumber();
  }

  if (!end) {
    return [startNumber];
  } else {
    if (!isNaturalNumber(end)) {
      throw invalidFocusNumber(end);
    }

    var list = [];

    for (var i = startNumber; i <= +end; i++) {
      list.push(i);
    }

    return list;
  }
}

function isNaturalNumber(n) {
  n = n.toString(); // force the value in case it is not

  var n1 = Math.abs(n),
      n2 = parseInt(n, 10);
  return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}

function parseSteps(rawSteps, lang) {
  var codes = getCodes(rawSteps);
  var stepsLines = getSlides(codes.reverse(), lang).reverse();
  var steps = rawSteps.map(function (step, i) {
    var lines = stepsLines[i];

    try {
      return parseStep(step, lines);
    } catch (e) {
      if (e.withStepIndex) {
        throw e.withStepIndex(i);
      } else {
        throw e;
      }
    }
  });
  steps.forEach(function (step) {
    var lines = step.lines,
        focusMap = step.focusMap;
    lines.forEach(function (line, index) {
      line.focus = focusMap.has(index);
      var columnFocus = focusMap.get(index);
      line.focusPerToken = Array.isArray(columnFocus);

      if (Array.isArray(columnFocus)) {
        // this mutates the tokens array in order to change it to the same line in other steps
        splitTokensToColumns(line.tokens);
        line.tokens = setTokenFocus(line.tokens, columnFocus);
      }
    });
  });
  return steps;
}

function parseStep(step, lines) {
  var focus = step.focus,
      rest = _objectWithoutPropertiesLoose(step, ["focus"]);

  var focusMap = focus ? parseFocus(focus) : getDefaultFocus(lines);
  var focusIndexes = Array.from(focusMap.keys());
  var focusStart = Math.min.apply(Math, focusIndexes);
  var focusEnd = Math.max.apply(Math, focusIndexes);
  return _extends({
    lines: lines,
    focusMap: focusMap,
    focusStart: focusStart,
    focusEnd: focusEnd,
    focusCenter: (focusStart + focusEnd + 1) / 2,
    focusCount: focusEnd - focusStart + 1
  }, rest);
}

function getDefaultFocus(lines) {
  var indexes = lines.map(function (line, index) {
    return line.isNew ? index : -1;
  }).filter(function (index) {
    return index !== -1;
  });
  return new Map(indexes.map(function (i) {
    return [i, true];
  }));
}

function splitTokensToColumns(tokenArray) {
  var tokens = Array.from(tokenArray);
  var key = 0;
  tokenArray.splice(0, tokenArray.length);
  tokens.forEach(function (token) {
    var chars = Array.from(token.content);
    chars.forEach(function (_char) {
      return tokenArray.push(_extends({}, token, {
        content: _char,
        key: key++
      }));
    });
  });
}

function setTokenFocus(tokens, focusColumns) {
  // Assumes that tokens are already splitted in columns
  // Return new token objects to avoid changing other steps tokens
  return tokens.map(function (token, i) {
    return _extends({}, token, {
      focus: focusColumns.includes(i)
    });
  });
}

function makeTheme(prismTheme, override) {
  if (override === void 0) {
    override = {};
  }

  return _extends({
    styles: prismTheme.styles,
    title: {
      background: prismTheme.plain.backgroundColor
    },
    subtitle: {
      color: "#d6deeb",
      background: "rgba(10,10,10,0.9)"
    },
    pre: {
      color: prismTheme.plain.color,
      background: prismTheme.plain.backgroundColor
    },
    code: {
      color: prismTheme.plain.color,
      background: prismTheme.plain.backgroundColor
    }
  }, override);
}

var prismTheme = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata"],
    style: {
      color: "#999988",
      fontStyle: "italic"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["string", "attr-value"],
    style: {
      color: "#e3116c"
    }
  }, {
    types: ["punctuation", "operator"],
    style: {
      color: "#393A34"
    }
  }, {
    types: ["entity", "url", "symbol", "number", "boolean", "variable", "constant", "property", "regex", "inserted"],
    style: {
      color: "#36acaa"
    }
  }, {
    types: ["atrule", "keyword", "attr-name", "selector"],
    style: {
      color: "#00a4db"
    }
  }, {
    types: ["function", "deleted", "tag"],
    style: {
      color: "#d73a49"
    }
  }, {
    types: ["function-variable"],
    style: {
      color: "#6f42c1"
    }
  }, {
    types: ["tag", "selector"],
    style: {
      color: "#00009f"
    }
  }]
};
var theme =
/*#__PURE__*/
makeTheme(prismTheme);

var prismTheme$1 = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [{
    types: ["prolog", "constant", "builtin"],
    style: {
      color: "rgb(189, 147, 249)"
    }
  }, {
    types: ["inserted", "function"],
    style: {
      color: "rgb(80, 250, 123)"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgb(255, 85, 85)"
    }
  }, {
    types: ["changed"],
    style: {
      color: "rgb(255, 184, 108)"
    }
  }, {
    types: ["punctuation", "symbol"],
    style: {
      color: "rgb(248, 248, 242)"
    }
  }, {
    types: ["string", "char", "tag", "selector"],
    style: {
      color: "rgb(255, 121, 198)"
    }
  }, {
    types: ["keyword", "variable"],
    style: {
      color: "rgb(189, 147, 249)",
      fontStyle: "italic"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(98, 114, 164)"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "rgb(241, 250, 140)"
    }
  }]
};
var theme$1 =
/*#__PURE__*/
makeTheme(prismTheme$1);

var prismTheme$2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#6c6783"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#e09142"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#9a86fd"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#eeebff"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#c4b9fe"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "at-rule", "placeholder", "variable"],
    style: {
      color: "#ffcc99"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#c4b9fe"
    }
  }]
};
var theme$2 =
/*#__PURE__*/
makeTheme(prismTheme$2);

var prismTheme$3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#b6ad9a"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#063289"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#b29762"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#2d2006"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#896724"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "at-rule"],
    style: {
      color: "#728fcb"
    }
  }, {
    types: ["placeholder", "variable"],
    style: {
      color: "#93abdc"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#896724"
    }
  }]
};
var theme$3 =
/*#__PURE__*/
makeTheme(prismTheme$3);

var prismTheme$4 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [{
    types: ["changed"],
    style: {
      color: "rgb(162, 191, 252)",
      fontStyle: "italic"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgba(239, 83, 80, 0.56)",
      fontStyle: "italic"
    }
  }, {
    types: ["inserted", "attr-name"],
    style: {
      color: "rgb(173, 219, 103)",
      fontStyle: "italic"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(99, 119, 119)",
      fontStyle: "italic"
    }
  }, {
    types: ["string", "url"],
    style: {
      color: "rgb(173, 219, 103)"
    }
  }, {
    types: ["variable"],
    style: {
      color: "rgb(214, 222, 235)"
    }
  }, {
    types: ["number"],
    style: {
      color: "rgb(247, 140, 108)"
    }
  }, {
    types: ["builtin", "char", "constant", "function"],
    style: {
      color: "rgb(130, 170, 255)"
    }
  }, {
    // This was manually added after the auto-generation
    // so that punctuations are not italicised
    types: ["punctuation"],
    style: {
      color: "rgb(199, 146, 234)"
    }
  }, {
    types: ["selector", "doctype"],
    style: {
      color: "rgb(199, 146, 234)",
      fontStyle: "italic"
    }
  }, {
    types: ["class-name"],
    style: {
      color: "rgb(255, 203, 139)"
    }
  }, {
    types: ["tag", "operator", "keyword"],
    style: {
      color: "rgb(127, 219, 202)"
    }
  }, {
    types: ["boolean"],
    style: {
      color: "rgb(255, 88, 116)"
    }
  }, {
    types: ["property"],
    style: {
      color: "rgb(128, 203, 196)"
    }
  }, {
    types: ["namespace"],
    style: {
      color: "rgb(178, 204, 214)"
    }
  }]
};
var theme$4 =
/*#__PURE__*/
makeTheme(prismTheme$4, {
  title: {
    background: "rgba(1, 22, 39, 0.8)"
  }
});

var colors = {
  "char": "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  "boolean": "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  "function": "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var prismTheme$5 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [{
    types: ["attr-name"],
    style: {
      color: colors.keyword
    }
  }, {
    types: ["attr-value"],
    style: {
      color: colors.string
    }
  }, {
    types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
    style: {
      color: colors.comment
    }
  }, {
    types: ["property", "number", "function-name", "constant", "symbol", "deleted"],
    style: {
      color: colors.primitive
    }
  }, {
    types: ["boolean"],
    style: {
      color: colors["boolean"]
    }
  }, {
    types: ["tag"],
    style: {
      color: colors.tag
    }
  }, {
    types: ["string"],
    style: {
      color: colors.string
    }
  }, {
    types: ["punctuation"],
    style: {
      color: colors.string
    }
  }, {
    types: ["selector", "char", "builtin", "inserted"],
    style: {
      color: colors["char"]
    }
  }, {
    types: ["function"],
    style: {
      color: colors["function"]
    }
  }, {
    types: ["operator", "entity", "url", "variable"],
    style: {
      color: colors.variable
    }
  }, {
    types: ["keyword"],
    style: {
      color: colors.keyword
    }
  }, {
    types: ["at-rule", "class-name"],
    style: {
      color: colors.className
    }
  }, {
    types: ["important"],
    style: {
      fontWeight: 400
    }
  }, {
    types: ["bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }]
};
var theme$5 =
/*#__PURE__*/
makeTheme(prismTheme$5);

var prismTheme$6 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [{
    types: ["changed"],
    style: {
      color: "rgb(255, 238, 128)"
    }
  }, {
    types: ["deleted"],
    style: {
      color: "rgba(239, 83, 80, 0.56)"
    }
  }, {
    types: ["inserted"],
    style: {
      color: "rgb(173, 219, 103)"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(179, 98, 255)",
      fontStyle: "italic"
    }
  }, {
    types: ["punctuation"],
    style: {
      color: "rgb(255, 255, 255)"
    }
  }, {
    types: ["constant"],
    style: {
      color: "rgb(255, 98, 140)"
    }
  }, {
    types: ["string", "url"],
    style: {
      color: "rgb(165, 255, 144)"
    }
  }, {
    types: ["variable"],
    style: {
      color: "rgb(255, 238, 128)"
    }
  }, {
    types: ["number", "boolean"],
    style: {
      color: "rgb(255, 98, 140)"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "rgb(255, 180, 84)"
    }
  }, {
    types: ["keyword", "operator", "property", "namespace", "tag", "selector", "doctype"],
    style: {
      color: "rgb(255, 157, 0)"
    }
  }, {
    types: ["builtin", "char", "constant", "function", "class-name"],
    style: {
      color: "rgb(250, 208, 0)"
    }
  }]
};
var theme$6 =
/*#__PURE__*/
makeTheme(prismTheme$6);

var prismTheme$7 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [{
    types: ["comment"],
    style: {
      color: "rgb(197, 200, 198)"
    }
  }, {
    types: ["string", "number", "builtin", "variable"],
    style: {
      color: "rgb(150, 152, 150)"
    }
  }, {
    types: ["class-name", "function", "tag", "attr-name"],
    style: {
      color: "rgb(40, 42, 46)"
    }
  }]
};
var theme$7 =
/*#__PURE__*/
makeTheme(prismTheme$7);

var prismTheme$8 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [{
    types: ["prolog"],
    style: {
      color: "rgb(0, 0, 128)"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(106, 153, 85)"
    }
  }, {
    types: ["builtin", "changed", "keyword"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["number", "inserted"],
    style: {
      color: "rgb(181, 206, 168)"
    }
  }, {
    types: ["constant"],
    style: {
      color: "rgb(100, 102, 149)"
    }
  }, {
    types: ["attr-name", "variable"],
    style: {
      color: "rgb(156, 220, 254)"
    }
  }, {
    types: ["deleted", "string", "attr-value"],
    style: {
      color: "rgb(206, 145, 120)"
    }
  }, {
    types: ["selector"],
    style: {
      color: "rgb(215, 186, 125)"
    }
  }, {
    // Fix tag color
    types: ["tag"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    // Fix tag color for HTML
    types: ["tag"],
    languages: ["markup"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["punctuation", "operator"],
    style: {
      color: "rgb(212, 212, 212)"
    }
  }, {
    // Fix punctuation color for HTML
    types: ["punctuation"],
    languages: ["markup"],
    style: {
      color: "#808080"
    }
  }, {
    types: ["function"],
    style: {
      color: "rgb(220, 220, 170)"
    }
  }, {
    types: ["class-name"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    types: ["char"],
    style: {
      color: "rgb(209, 105, 105)"
    }
  }]
};
var theme$8 =
/*#__PURE__*/
makeTheme(prismTheme$8);

var ThemeContext =
/*#__PURE__*/
React.createContext(null);

function useSafeTheme() {
  var contextTheme = React.useContext(ThemeContext);
  var theme$1 = contextTheme || theme;
  return theme$1;
}

function useTokenStyles() {
  var theme = useSafeTheme();
  var themeStylesByType = React.useMemo(function () {
    var themeStylesByType = Object.create(null);
    var styles = theme.styles;
    styles.forEach(function (_ref) {
      var types = _ref.types,
          style = _ref.style;
      types.forEach(function (type) {
        themeStylesByType[type] = Object.assign(themeStylesByType[type] || {}, style);
      });
    });
    return themeStylesByType;
  }, [theme]);
  var getStyleForToken = React.useMemo(function () {
    return function (token) {
      return themeStylesByType[token.type] || {};
    };
  }, [themeStylesByType]);
  return getStyleForToken;
}

function usePreStyle() {
  var theme = useSafeTheme();
  return theme.pre || {};
}

function useContainerStyle() {
  var theme = useSafeTheme();
  return theme.container || {};
}

function useTitleStyle() {
  var theme = useSafeTheme();
  var base = {
    position: "absolute",
    top: 0,
    width: "100%",
    margin: 0,
    padding: "1em 0"
  };
  var style = theme.title || {};
  return _extends({}, base, style);
}

function useSubtitleStyle() {
  var theme = useSafeTheme();
  var base = {
    position: "absolute",
    bottom: 0,
    width: "calc(100% - 2em)",
    boxSizing: "border-box",
    margin: "0.3em 1em",
    padding: "0.5em",
    background: "rgba(2,2,2,0.9)"
  };
  var style = theme.subtitle || {};
  return _extends({}, base, style);
}

var Tuple =
/*#__PURE__*/
function () {
  function Tuple(prev, next) {
    this.prev = prev;
    this.next = next;
  }

  var _proto = Tuple.prototype;

  _proto.spread = function spread() {
    var prev = this.prev;
    var next = this.next;
    return [prev, next];
  };

  _proto.select = function select(selector) {
    var _this$spread = this.spread(),
        prev = _this$spread[0],
        next = _this$spread[1];

    var newPrev = prev === null ? null : prev === undefined ? undefined : selector(prev),
        newNext = next === null ? null : next === undefined ? undefined : selector(next);
    return new Tuple(newPrev, newNext);
  };

  _proto.selectMany = function selectMany(selector) {
    var _this$spread2 = this.spread(),
        prev = _this$spread2[0],
        next = _this$spread2[1];

    var newPrev = prev === null ? null : prev === undefined ? undefined : selector(prev),
        newNext = next === null ? null : next === undefined ? undefined : selector(next);
    return new ArrayTuple(newPrev, newNext);
  };

  _proto.get = function get(_key) {
    throw Error("Get only supported in ArrayTuple");
  };

  _proto.map = function map(_mapper) {
    throw Error("Map only supported in ArrayTuple");
  };

  return Tuple;
}();
var ArrayTuple =
/*#__PURE__*/
function (_Tuple) {
  _inheritsLoose(ArrayTuple, _Tuple);

  function ArrayTuple() {
    return _Tuple.apply(this, arguments) || this;
  }

  var _proto2 = ArrayTuple.prototype;

  _proto2._getChildrenMap = function _getChildrenMap() {
    if (!this._dict) {
      var _this$spread3 = this.spread(),
          maybePrevs = _this$spread3[0],
          maybeNexts = _this$spread3[1];

      var prevs = maybePrevs || [];
      var nexts = maybeNexts || [];
      var unsortedMap = new Map(prevs.map(function (prev) {
        return [prev.key, {
          prev: prev
        }];
      }));
      nexts.forEach(function (next) {
        var _ref = unsortedMap.get(next.key) || {
          prev: undefined
        },
            prev = _ref.prev;

        unsortedMap.set(next.key, {
          prev: prev,
          next: next
        });
      });
      var sortedKeys = Array.from(unsortedMap.keys());
      sortedKeys.sort(function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      });
      this._dict = new Map(sortedKeys.map(function (key) {
        var _ref2 = unsortedMap.get(key) || {},
            _ref2$prev = _ref2.prev,
            prev = _ref2$prev === void 0 ? undefined : _ref2$prev,
            _ref2$next = _ref2.next,
            next = _ref2$next === void 0 ? undefined : _ref2$next;

        return [key, new Tuple(prev, next)];
      }));
    }

    return this._dict;
  };

  _proto2.get = function get(key) {
    var childrenMap = this._getChildrenMap();

    return childrenMap.get(key);
  };

  _proto2.map = function map(mapper) {
    var _this = this;

    var childrenMap = this._getChildrenMap();

    var result = [];
    childrenMap.forEach(function (tuple, key) {
      return result.push(mapper(tuple, key, _this));
    });
    return result;
  };

  return ArrayTuple;
}(Tuple);

var Context =
/*#__PURE__*/
function () {
  function Context(tuple, t, parent) {
    this.tuple = tuple;
    this.t = t;
    this.parent = parent;
  }

  var _proto = Context.prototype;

  _proto.useSelect = function useSelect(selector) {
    var _this = this;

    var newTuple = React.useMemo(function () {
      return _this.tuple.select(selector);
    }, [this.tuple]);
    return new Context(newTuple, this.t);
  };

  _proto.useSelectMany = function useSelectMany(selector) {
    var _this2 = this;

    var newTuple = React.useMemo(function () {
      return _this2.tuple.selectMany(selector);
    }, [this.tuple]);
    return new ListContext(newTuple, this.t);
  };

  _proto.spread = function spread() {
    return this.tuple.spread();
  };

  _proto.animate = function animate(animation, config) {
    if (config === void 0) {
      config = {};
    }

    var _this$tuple$spread = this.tuple.spread(),
        prev = _this$tuple$spread[0],
        next = _this$tuple$spread[1];

    if (config.when && !config.when(prev, next)) {
      return {};
    }

    var staggeredT = this.t;

    if (config.stagger) {
      if (!this.parent) {
        throw Error("Can't use stagger without a parent context");
      }

      var items = this.parent.map(function (childCtx) {
        var _childCtx$spread = childCtx.spread(),
            prevChild = _childCtx$spread[0],
            nextChild = _childCtx$spread[1];

        return {
          isSelected: !config.when || config.when(prevChild, nextChild),
          isThisChild: prevChild === prev && nextChild === next
        };
      }).filter(function (x) {
        return x.isSelected;
      });
      var N = items.length;

      if (N > 1) {
        var currentIndex = items.findIndex(function (x) {
          return x.isThisChild;
        });
        var duration = 1 - config.stagger;
        var tick = config.stagger / (N - 1);
        staggeredT = Math.min(1, Math.max(0, (this.t - currentIndex * tick) / duration));
      }
    }

    return animation(prev, next, staggeredT);
  };

  _proto.animations = function animations(_animations) {
    var _this3 = this;

    var results = _animations.map(function (_ref) {
      var animation = _ref.animation,
          config = _objectWithoutPropertiesLoose(_ref, ["animation"]);

      return _this3.animate(animation, config);
    });

    return merge(results);
  };

  return Context;
}();
var ListContext =
/*#__PURE__*/
function (_Context) {
  _inheritsLoose(ListContext, _Context);

  function ListContext(tuple, t) {
    var _this4;

    _this4 = _Context.call(this, tuple, t) || this;
    _this4.tuple = tuple;
    return _this4;
  }

  var _proto2 = ListContext.prototype;

  _proto2.map = function map(mapper) {
    var _this5 = this;

    return this.tuple.map(function (childTuple, key) {
      return mapper(new Context(childTuple, _this5.t, _this5), key);
    });
  };

  return ListContext;
}(Context);
function useAnimationContext(items, playhead) {
  var prev = items[Math.floor(playhead)];
  var next = items[Math.floor(playhead) + 1];
  var tuple = React.useMemo(function () {
    return new Tuple(prev, next);
  }, [prev, next]);
  return new Context(tuple, playhead % 1);
}
var MULTIPLY = "multiply";

function merge(results, composite) {
  if (composite === void 0) {
    composite = MULTIPLY;
  }

  var firstResult = results[0];

  if (results.length < 2) {
    return firstResult;
  }

  if (Array.isArray(firstResult)) {
    return mergeArrays(results, composite);
  } else {
    return mergeObjects(results, composite);
  }
}

function mergeObjects(results, composite) {
  var merged = Object.assign.apply(Object, [{}].concat(results));

  if (composite === MULTIPLY) {
    var opacities = results.map(function (x) {
      return x.opacity;
    }).filter(function (x) {
      return x != null;
    });

    if (opacities.length !== 0) {
      merged.opacity = opacities.reduce(function (a, b) {
        return a * b;
      });
    }
  }

  return merged;
}

function mergeArrays(results, composite) {
  var firstResult = results[0];
  return firstResult.map(function (_, i) {
    return merge(results.map(function (result) {
      return result[i];
    }), composite);
  });
}

var easing = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

var MULTIPLY$1 = "multiply";
/* eslint-disable */

function mergeResults(results, composite) {
  if (composite === void 0) {
    composite = null;
  }

  var firstResult = results[0];

  if (results.length < 2) {
    return firstResult;
  }

  if (Array.isArray(firstResult)) {
    return firstResult.map(function (_, i) {
      return mergeResults(results.map(function (result) {
        return result[i];
      }), composite);
    });
  } else {
    var merged = Object.assign.apply(Object, [{}].concat(results));

    if (composite === MULTIPLY$1) {
      var opacities = results.map(function (x) {
        return x.opacity;
      }).filter(function (x) {
        return x != null;
      });

      if (opacities.length !== 0) {
        merged.opacity = opacities.reduce(function (a, b) {
          return a * b;
        });
      }
    }

    return merged;
  }
}

var playhead = {
  always: function always(props, context) {
    return function (t) {
      return props.value;
    };
  },
  step: function step(props, context) {
    return function (t) {
      var from = props.from,
          to = props.to;
      return t < 0.5 ? from : to;
    };
  },
  tween: function tween(props, context) {
    return function (t) {
      var from = props.from,
          to = props.to,
          _props$ease = props.ease,
          ease = _props$ease === void 0 ? easing.linear : _props$ease;
      var style = {};
      Object.keys(from).forEach(function (key) {
        var value = from[key] + (to[key] - from[key]) * ease(t);

        if (key === "x") {
          style["transform"] = "translateX(" + value + "px)";
        } else {
          style[key] = value;
        }
      });
      return style;
    };
  },
  chain: function chain(_ref, ctx) {
    var fns = _ref.children,
        durations = _ref.durations;
    return function (t) {
      var style = run(fns[0], 0, ctx);
      var lowerDuration = 0;

      for (var i = 0; i < fns.length; i++) {
        var fn = fns[i];
        var thisDuration = durations[i];
        var upperDuration = lowerDuration + thisDuration;

        if (lowerDuration <= t && t <= upperDuration) {
          var innerT = (t - lowerDuration) / thisDuration;
          style = mergeResults([style, run(fn, innerT, ctx)]);
        } else if (upperDuration < t) {
          // merge the end of previous animation
          style = mergeResults([style, run(fn, 1, ctx)]);
        } else if (t < lowerDuration) {
          // merge the start of future animation
          style = mergeResults([run(fn, 0, ctx), style]);
        }

        lowerDuration = upperDuration;
      }

      return style;
    };
  },
  delay: function delay() {
    return function () {
      return {};
    };
  },
  parallel: function parallel(_ref2, ctx) {
    var fns = _ref2.children;
    return function (t) {
      var styles = fns.map(function (fn) {
        return run(fn, t, ctx);
      });
      var result = mergeResults(styles, MULTIPLY$1);
      return result;
    };
  },
  list: function list(_ref3, ctx) {
    var items = _ref3.forEach,
        children = _ref3.children;
    return function (t) {
      var mapper = children[0];
      var results = items.map(mapper);
      return results.map(function (element) {
        return run(element, t, ctx);
      });
    };
  }
};
function createAnimation(type, config) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var props = _extends({}, config, {
    children: children
  });

  return {
    type: typeof type === "string" ? playhead[type] : type,
    props: props
  };
}
function Context$1() {
  throw Error("shouldnt run Context");
}
function run(node, t, context) {
  if (context === void 0) {
    context = {};
  }

  if (node.type === Context$1) {
    var _node$props = node.props,
        children = _node$props.children,
        patch = _objectWithoutPropertiesLoose(_node$props, ["children"]);

    var newContext = _extends({}, context, patch);

    return run(children[0], t, newContext);
  }

  var result = node.type(node.props, context);

  if (result.type) {
    return run(result, t, context);
  } else {
    return result(t);
  }
}

/* @jsx createAnimation */

function FadeIn() {
  return createAnimation("tween", {
    from: {
      opacity: 0
    },
    to: {
      opacity: 1
    }
  });
}

function FadeOut() {
  return createAnimation("tween", {
    from: {
      opacity: 1
    },
    to: {
      opacity: 0
    }
  });
}

function FadeOutIn() {
  return createAnimation("chain", {
    durations: [0.5, 0.5]
  }, createAnimation(FadeOut, null), createAnimation(FadeIn, null));
}

var dx = 250;
var offOpacity = 0.3;
var outOpacity = 0;
var outHieght = 0;

var SlideToLeft = function SlideToLeft() {
  return createAnimation("tween", {
    from: {
      x: 0,
      opacity: 1
    },
    to: {
      x: -dx,
      opacity: outOpacity
    },
    ease: easing.easeInQuad
  });
};

function ShrinkHeight(_ref) {
  var lineHeight = _ref.lineHeight;

  if (!lineHeight) {
    return createAnimation("step", {
      from: {
        height: null
      },
      to: {
        height: 0
      }
    });
  }

  return createAnimation("tween", {
    from: {
      height: lineHeight
    },
    to: {
      height: outHieght
    },
    ease: easing.easeInOutQuad
  });
}

function ExitLine(_ref2) {
  var lineHeight = _ref2.lineHeight;
  return createAnimation("chain", {
    durations: [0.35, 0.3, 0.35]
  }, createAnimation(SlideToLeft, null), createAnimation(ShrinkHeight, {
    lineHeight: lineHeight
  }));
}

var SlideFromRight = function SlideFromRight() {
  return createAnimation("tween", {
    from: {
      x: dx,
      opacity: outOpacity
    },
    to: {
      x: 0,
      opacity: 1
    },
    ease: easing.easeOutQuad
  });
};

function GrowHeight(_ref3) {
  var lineHeight = _ref3.lineHeight;

  if (!lineHeight) {
    return createAnimation("step", {
      from: {
        height: 0
      },
      to: {
        height: null
      }
    });
  }

  return createAnimation("tween", {
    from: {
      height: outHieght
    },
    to: {
      height: lineHeight
    },
    ease: easing.easeInOutQuad
  });
}

function EnterLine(_ref4) {
  var lineHeight = _ref4.lineHeight;
  return createAnimation("chain", {
    durations: [0.35, 0.3, 0.35]
  }, createAnimation("delay", null), createAnimation(GrowHeight, {
    lineHeight: lineHeight
  }), createAnimation(SlideFromRight, null));
}

var fadeIn = function fadeIn(t) {
  return run(createAnimation(FadeIn, null), t);
};
var fadeOut = function fadeOut(t) {
  return run(createAnimation(FadeOut, null), t);
};
var fadeOutIn = function fadeOutIn(t) {
  return run(createAnimation(FadeOutIn, null), t);
};
function switchText(prev, next, t) {
  // TODO merge with fadeBackground and fadeText
  if (t < 0.5) {
    return prev && prev.value;
  } else {
    return next && next.value;
  }
}

function any(prev, next) {
  return prev || next;
}

var exitLine = function exitLine(prev, next, t) {
  var dimensions = any(prev, next).dimensions;
  return run(createAnimation(ExitLine, {
    lineHeight: dimensions && dimensions.lineHeight
  }), t);
};
var enterLine = function enterLine(prev, next, t) {
  var dimensions = any(prev, next).dimensions;
  return run(createAnimation(EnterLine, {
    lineHeight: dimensions && dimensions.lineHeight
  }), t);
};
var focusLine = function focusLine(prev, next, t) {
  return run(createAnimation("tween", {
    from: {
      opacity: prev && prev.focus ? 1 : offOpacity
    },
    to: {
      opacity: next && next.focus ? 1 : offOpacity
    }
  }), t);
};
var focusToken = function focusToken(prev, next, t) {
  var from = prev && prev.focus === false ? offOpacity : 1;
  var to = next && next.focus === false ? offOpacity : 1;
  return run(createAnimation("tween", {
    from: {
      opacity: from
    },
    to: {
      opacity: to
    }
  }), t);
};
var tween = function tween(from, to) {
  return function (_prev, _next, t) {
    var result = run(createAnimation("tween", {
      from: {
        value: from || 0
      },
      to: {
        value: to || 0
      },
      ease: easing.easeInOutQuad
    }), t);
    return result.value;
  };
};
var scaleToFocus = function scaleToFocus(prev, next, t) {
  var dimensions = any(prev, next).dimensions;

  if (!dimensions) {
    return function (_) {
      return {
        scale: 1
      };
    };
  }

  var prevZoom = getZoom(prev);
  var nextZoom = getZoom(next);
  return run(createAnimation("tween", {
    from: {
      scale: prevZoom || nextZoom
    },
    to: {
      scale: nextZoom || prevZoom
    },
    ease: easing.easeInOutQuad
  }), t);
};

function getZoom(step) {
  if (!step) return null;
  var _step$dimensions = step.dimensions,
      paddingBottom = _step$dimensions.paddingBottom,
      paddingTop = _step$dimensions.paddingTop,
      containerHeight = _step$dimensions.containerHeight,
      containerWidth = _step$dimensions.containerWidth,
      contentWidth = _step$dimensions.contentWidth,
      lineHeight = _step$dimensions.lineHeight;
  var contentHeight = step.focusCount * lineHeight;
  var availableHeight = containerHeight - Math.max(paddingBottom, paddingTop) * 2;
  var yZoom = availableHeight / contentHeight; // if there are lines that are too long for the container

  var xZoom = 0.9 * containerWidth / contentWidth;
  return Math.min(yZoom, 1, xZoom); // return 1;
}

function CodeSurferContainer(_ref) {
  var stepPlayhead = _ref.stepPlayhead,
      dimensions = _ref.dimensions,
      steps = _ref.steps;
  var ctx = useAnimationContext(steps, stepPlayhead);
  return React.createElement("div", {
    className: "cs-container",
    style: _extends({}, useContainerStyle(), {
      width: "100%",
      height: dimensions ? dimensions.containerHeight : "100%",
      maxHeight: "100%",
      position: "relative"
    })
  }, React.createElement(CodeSurferContent, {
    dimensions: dimensions,
    ctx: ctx
  }), React.createElement(Title, {
    ctx: ctx.useSelect(function (step) {
      return step.title;
    })
  }), React.createElement(Subtitle, {
    ctx: ctx.useSelect(function (step) {
      return step.subtitle;
    })
  }));
}

var heightChangingAnimations = [{
  animation: exitLine,
  when: function when(prev, next) {
    return prev && !next;
  },
  stagger: 0.2
}, {
  animation: enterLine,
  when: function when(prev, next) {
    return next && !prev;
  },
  stagger: 0.2
}];
/**
 * This part wasn't easy...
 * We need to adjust the scroll as the lines keep changing height
 * So we animate between the prev focus center and the next focus center
 * but taking into acount the height of the lines that are on top of the center
 * for each frame
 */

function useScrollTop(dimensions, stepCtx) {
  if (!dimensions) return 0;
  var linesCtx = stepCtx.useSelectMany(function (step) {
    return step.lines;
  });

  var _stepCtx$spread = stepCtx.spread(),
      prevStep = _stepCtx$spread[0],
      nextStep = _stepCtx$spread[1];

  var _React$useMemo = React.useMemo(function () {
    var allPrevLines = linesCtx.map(function (ctx) {
      return ctx.animate(function (prev, _next) {
        return prev;
      });
    });
    var allNextLines = linesCtx.map(function (ctx) {
      return ctx.animate(function (_prev, next) {
        return next;
      });
    });
    var prevCenter = prevStep ? prevStep.focusCenter : 0;
    var nextCenter = nextStep ? nextStep.focusCenter : 0;
    var prevCenterLine = prevStep && prevStep.lines[Math.floor(prevCenter)];
    var nextCenterLine = nextStep && nextStep.lines[Math.floor(nextCenter)];
    var realPrevCenter = prevStep ? allPrevLines.indexOf(prevCenterLine) + prevCenter % 1 : 0;
    var realNextCenter = nextStep ? allNextLines.indexOf(nextCenterLine) + nextCenter % 1 : 0;
    return [realPrevCenter, realNextCenter];
  }, [prevStep, nextStep]),
      realPrevCenter = _React$useMemo[0],
      realNextCenter = _React$useMemo[1];

  var currentCenter = stepCtx.animate(tween(realPrevCenter, realNextCenter));
  var scrollTop = 0;
  var lineStyles = linesCtx.map(function (ctx) {
    return ctx.animations(heightChangingAnimations);
  });
  var i = 0;

  while (i <= currentCenter - 1) {
    var h = lineStyles[i].height;
    scrollTop += h == null ? dimensions.lineHeight : h;
    i += 1;
  }

  if (i != currentCenter) {
    var _h = lineStyles[i].height;
    var height = _h == null ? dimensions.lineHeight : _h;
    scrollTop += height * (currentCenter - i);
  }

  return scrollTop;
}

function CodeSurferContent(_ref2) {
  var dimensions = _ref2.dimensions,
      ctx = _ref2.ctx;
  var ref = React.useRef(null);
  var scrollTop = useScrollTop(dimensions, ctx);
  React.useLayoutEffect(function () {
    if (ref.current == null) return;
    ref.current.scrollTop = scrollTop;
  }, [scrollTop]);

  var _ctx$animate = ctx.animate(scaleToFocus),
      scale = _ctx$animate.scale;

  var verticalOrigin = dimensions ? dimensions.containerHeight / 2 + scrollTop : 0;
  var linesCtx = ctx.useSelectMany(function (step) {
    return step.lines;
  });
  return React.createElement("pre", {
    className: "cs-content",
    ref: ref,
    style: _extends({}, usePreStyle(), {
      margin: 0,
      height: "100%",
      overflow: "hidden"
    })
  }, React.createElement("code", {
    className: "cs-scaled-content",
    style: _extends({}, usePreStyle(), {
      display: "block",
      height: dimensions ? dimensions.contentHeight : "100%",
      width: dimensions && dimensions.contentWidth,
      margin: dimensions && "0 " + (dimensions.containerWidth - dimensions.contentWidth) / 2 + "px",
      transform: "scale(" + scale + ")",
      transformOrigin: "center " + verticalOrigin + "px"
    })
  }, React.createElement("div", {
    style: {
      height: dimensions && dimensions.containerHeight / 2
    }
  }), linesCtx.map(function (ctx, key) {
    return React.createElement(Line, {
      ctx: ctx,
      key: key
    });
  }), React.createElement("div", {
    style: {
      height: dimensions && dimensions.containerHeight / 2
    }
  })));
}

function Line(_ref3) {
  var ctx = _ref3.ctx;
  var lineStyle = ctx.animations([].concat(heightChangingAnimations, [{
    animation: focusLine
  }]));

  var _ctx$animate2 = ctx.animate(function (prev, next) {
    var line = prev || next;
    return {
      lineTokens: line.tokens,
      key: line.key,
      focusPerToken: prev && prev.focusPerToken || next && next.focusPerToken
    };
  }),
      lineTokens = _ctx$animate2.lineTokens,
      key = _ctx$animate2.key,
      focusPerToken = _ctx$animate2.focusPerToken;

  var getStyleForToken = useTokenStyles();
  var tokens = [];
  var tokensCtx = ctx.useSelectMany(function (line) {
    return line.tokens;
  });

  if (focusPerToken) {
    tokens = tokensCtx.map(function (tokenCtx) {
      return _extends({}, tokenCtx.animate(function (prev, next) {
        return prev || next;
      }), {
        animatedStyle: tokenCtx.animate(focusToken)
      });
    });
  } else {
    tokens = lineTokens.map(function (token) {
      return _extends({}, token, {
        animatedStyle: {}
      });
    });
  }

  return React.createElement("div", {
    style: _extends({
      overflow: "hidden"
    }, lineStyle)
  }, React.createElement("div", {
    style: {
      display: "inline-block"
    },
    className: "cs-line cs-line-" + key
  }, tokens.map(function (token, i) {
    return React.createElement("span", {
      key: i,
      style: _extends({}, getStyleForToken(token), token.animatedStyle)
    }, token.content);
  })));
}

function Title(_ref4) {
  var ctx = _ref4.ctx;
  var text = ctx.animate(switchText);
  var bgStyle = ctx.animate(fadeBackground);
  var textStyle = ctx.animate(fadeText);
  if (!text) return null;
  return React.createElement("h4", {
    className: "cs-title",
    style: _extends({}, useTitleStyle(), bgStyle)
  }, React.createElement("span", {
    style: textStyle
  }, text));
}

function Subtitle(_ref5) {
  var ctx = _ref5.ctx;
  var text = ctx.animate(switchText);
  var bgStyle = ctx.animate(fadeBackground);
  var textStyle = ctx.animate(fadeText);
  if (!text) return null;
  return React.createElement("p", {
    className: "cs-subtitle",
    style: _extends({}, useSubtitleStyle(), bgStyle)
  }, React.createElement("span", {
    style: textStyle
  }, text));
}

var fadeBackground = function fadeBackground(prev, next, t) {
  var opacity = 1;

  if (!prev) {
    opacity = t;
  }

  if (!next) {
    opacity = 1 - t;
  }

  return {
    opacity: opacity
  };
};

var fadeText = function fadeText(prev, next, t) {
  if (prev && next && prev.value !== next.value) {
    return fadeOutIn(t);
  }

  if (!prev) {
    return fadeIn(t);
  }

  if (!next) {
    return fadeOut(t);
  }

  return {
    opacity: 1
  };
};

function useWindowResize(handler, deps) {
  React.useEffect(function () {
    window.addEventListener("resize", handler);
    return function () {
      window.removeEventListener("resize", handler);
    };
  }, deps);
}

function useDimensions(ref, steps) {
  var _React$useState = React.useState(null),
      result = _React$useState[0],
      setResult = _React$useState[1];

  useWindowResize(function () {
    return setResult(null);
  }, [setResult]);
  React.useLayoutEffect(function () {
    if (!ref.current) return;
    if (result) return;
    var containers = ref.current.querySelectorAll(".cs-container");
    var stepsDimensions = Array.from(containers).map(function (container, i) {
      return getStepDimensions(container, steps[i]);
    });
    var containerHeight = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.containerHeight;
    }));
    var containerWidth = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.containerWidth;
    }));
    var contentWidth = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.contentWidth;
    }));
    var lineHeight = Math.max.apply(Math, stepsDimensions.map(function (d) {
      return d.lineHeight;
    }));
    setResult({
      dimensions: {
        lineHeight: lineHeight,
        contentWidth: contentWidth,
        containerHeight: containerHeight,
        containerWidth: containerWidth
      },
      steps: steps.map(function (step, i) {
        return _extends({}, step, {
          lines: step.lines.map(function (l) {
            return _extends({}, l, {
              dimensions: {
                lineHeight: stepsDimensions[i].lineHeight
              }
            });
          }),
          dimensions: {
            paddingTop: stepsDimensions[i].paddingTop,
            paddingBottom: stepsDimensions[i].paddingBottom,
            lineHeight: stepsDimensions[i].lineHeight,
            contentWidth: contentWidth,
            containerHeight: containerHeight,
            containerWidth: containerWidth
          }
        });
      })
    });
  }, [result]);
  return result || {};
}

function getStepDimensions(container, step) {
  var longestLine = getLongestLine(step);
  var longestLineKey = longestLine && longestLine.key;
  var longestLineSpan = container.querySelector(".cs-line-" + longestLineKey);
  var containerParent = container.parentElement;
  var title = container.querySelector(".cs-title");
  var subtitle = container.querySelector(".cs-subtitle");
  var lineCount = step.lines.length;
  var heightOverflow = containerParent.scrollHeight - containerParent.clientHeight;
  var avaliableHeight = container.scrollHeight - heightOverflow;
  var lineHeight = longestLineSpan ? longestLineSpan.clientHeight : 0;
  var paddingTop = title ? outerHeight(title) : lineHeight;
  var paddingBottom = subtitle ? outerHeight(subtitle) : lineHeight;
  var codeHeight = lineCount * lineHeight * 2; // const maxContentHeight = codeHeight + paddingTop + paddingBottom;
  // const containerHeight = Math.min(maxContentHeight, avaliableHeight);

  var containerHeight = avaliableHeight;
  var containerWidth = container.clientWidth;
  var contentHeight = codeHeight + containerHeight;
  var contentWidth = longestLineSpan ? longestLineSpan.clientWidth : 0;
  return {
    lineHeight: lineHeight,
    contentHeight: contentHeight,
    contentWidth: contentWidth,
    paddingTop: paddingTop,
    paddingBottom: paddingBottom,
    containerHeight: containerHeight,
    containerWidth: containerWidth
  };
}

function outerHeight(element) {
  var styles = window.getComputedStyle(element);
  var margin = parseFloat(styles["marginTop"] || "0") + parseFloat(styles["marginBottom"] || "0");
  return element.offsetHeight + margin;
}

function getLongestLine(step) {
  if (!step || step.lines.length === 0) {
    return null;
  }

  return step.lines.reduce(function (a, b) {
    return a.content.length > b.content.length ? a : b;
  });
}

function CodeSurfer(_ref) {
  var progress = _ref.progress,
      inputSteps = _ref.steps,
      theme = _ref.theme;
  var steps = parseSteps(inputSteps, inputSteps[0].lang || "javascript"); // const stepIndex = Math.round(progress);

  var ref = React.useRef(null);

  var _useDimensions = useDimensions(ref, steps),
      dimensions = _useDimensions.dimensions,
      stepsWithDimensions = _useDimensions.steps;

  if (!dimensions) {
    return React.createElement(ThemeContext.Provider, {
      value: theme
    }, React.createElement("div", {
      ref: ref,
      style: {
        overflow: "auto",
        height: "100%",
        width: "100%"
      }
    }, steps.map(function (_step, i) {
      return React.createElement("div", {
        key: i,
        style: {
          overflow: "auto",
          height: "100%",
          width: "100%"
        }
      }, React.createElement(CodeSurferContainer, {
        steps: steps,
        stepPlayhead: i
      }));
    })));
  } else {
    return React.createElement(ThemeContext.Provider, {
      value: theme
    }, React.createElement("div", {
      style: {
        height: "100%",
        width: "100%",
        overflow: "auto"
      },
      ref: ref
    }, React.createElement(CodeSurferContainer, {
      steps: stepsWithDimensions,
      stepPlayhead: progress,
      dimensions: dimensions
    })));
  }
}

export default CodeSurfer;
export { theme$1 as dracula, theme$2 as duotoneDark, theme$3 as duotoneLight, theme as github, theme$4 as nightOwl, theme$5 as oceanicNext, theme$6 as shadesOfPurple, theme$7 as ultramin, theme$8 as vsDark };
//# sourceMappingURL=standalone.esm.js.map
